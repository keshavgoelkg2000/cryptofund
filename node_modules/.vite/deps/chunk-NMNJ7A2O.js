import {
  getInjectedMetamaskProvider
} from "./chunk-XBH54BOD.js";
import {
  getInjectedPhantomProvider
} from "./chunk-R5U57HIL.js";
import {
  getInjectedRainbowProvider
} from "./chunk-BFYOF2QD.js";
import {
  e,
  i
} from "./chunk-DH52Z52Z.js";
import {
  _classPrivateMethodGet,
  _classPrivateMethodInitSpec
} from "./chunk-ZXQ5YOFG.js";
import {
  ERC6551_REGISTRY
} from "./chunk-PMPHILAH.js";
import {
  Connector,
  WagmiAdapter
} from "./chunk-6FDWOVUB.js";
import {
  getInjectedOKXProvider
} from "./chunk-YS4BYOTJ.js";
import {
  walletIds
} from "./chunk-3MM6MTCA.js";
import {
  assertWindowEthereum
} from "./chunk-BL3IWORX.js";
import {
  normalizeChainId
} from "./chunk-2NOQI5T3.js";
import {
  _classPrivateFieldGet,
  _classPrivateFieldInitSpec,
  _classPrivateFieldSet
} from "./chunk-64WJJLDE.js";
import {
  _defineProperty
} from "./chunk-6OBQOEDS.js";
import {
  $t2 as $t,
  D2 as D,
  IEvents,
  JsonRpcProvider,
  N,
  Qt,
  RELAY_JSONRPC,
  V,
  Vn,
  _,
  detect,
  encodeIss,
  esm_default,
  esm_exports,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  generateKeyPair,
  getBigIntRpcId,
  init_esm,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  jt,
  payloadId,
  q,
  require_browser,
  require_chacha20poly1305,
  require_cjs,
  require_cjs2,
  require_cjs3,
  require_cjs4,
  require_cjs5,
  require_hkdf,
  require_lodash,
  require_query_string,
  require_random,
  require_sha256,
  require_x25519,
  safeJsonParse,
  safeJsonStringify,
  signJWT,
  zr
} from "./chunk-PDDJNFOE.js";
import {
  require_events
} from "./chunk-UR4CD6SH.js";
import {
  NATIVE_TOKEN_ADDRESS,
  fetchCurrencyValue,
  isNativeToken,
  normalizePriceValue
} from "./chunk-EZZX3VV7.js";
import {
  c1,
  defaultChains,
  getValidChainRPCs,
  updateChainRPCs
} from "./chunk-QZ5GEFHZ.js";
import {
  eventemitter3_default
} from "./chunk-I4TCAHS5.js";
import {
  concat,
  fromString,
  toString
} from "./chunk-457LSDR5.js";
import {
  Contract,
  init_lib as init_lib3,
  utils_exports
} from "./chunk-DTB7S26G.js";
import {
  getDefaultProvider,
  lib_exports
} from "./chunk-O2O3ULHT.js";
import {
  require_utils
} from "./chunk-MD4EOBS2.js";
import {
  Wallet
} from "./chunk-3327Y7YD.js";
import {
  Signer,
  hashMessage,
  init_lib11 as init_lib,
  init_lib15 as init_lib2,
  recoverAddress
} from "./chunk-KAA6TFSL.js";
import {
  _global,
  import_process,
  init_shim,
  require_buffer
} from "./chunk-6SWLQQ3Q.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-GN3OLCG2.js";

// node_modules/unfetch/dist/unfetch.module.js
var unfetch_module_exports = {};
__export(unfetch_module_exports, {
  default: () => unfetch_module_default
});
function unfetch_module_default(e2, n2) {
  return n2 = n2 || {}, new Promise(function(t, r) {
    var s = new XMLHttpRequest(), o2 = [], u3 = [], i3 = {}, a2 = function() {
      return { ok: 2 == (s.status / 100 | 0), statusText: s.statusText, status: s.status, url: s.responseURL, text: function() {
        return Promise.resolve(s.responseText);
      }, json: function() {
        return Promise.resolve(s.responseText).then(JSON.parse);
      }, blob: function() {
        return Promise.resolve(new Blob([s.response]));
      }, clone: a2, headers: { keys: function() {
        return o2;
      }, entries: function() {
        return u3;
      }, get: function(e3) {
        return i3[e3.toLowerCase()];
      }, has: function(e3) {
        return e3.toLowerCase() in i3;
      } } };
    };
    for (var l2 in s.open(n2.method || "get", e2, true), s.onload = function() {
      s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(e3, n3, t2) {
        o2.push(n3 = n3.toLowerCase()), u3.push([n3, t2]), i3[n3] = i3[n3] ? i3[n3] + "," + t2 : t2;
      }), t(a2());
    }, s.onerror = r, s.withCredentials = "include" == n2.credentials, n2.headers)
      s.setRequestHeader(l2, n2.headers[l2]);
    s.send(n2.body || null);
  });
}
var init_unfetch_module = __esm({
  "node_modules/unfetch/dist/unfetch.module.js"() {
    init_shim();
  }
});

// node_modules/isomorphic-unfetch/browser.js
var require_browser2 = __commonJS({
  "node_modules/isomorphic-unfetch/browser.js"(exports, module) {
    init_shim();
    module.exports = self.fetch || (self.fetch = (init_unfetch_module(), __toCommonJS(unfetch_module_exports)).default || (init_unfetch_module(), __toCommonJS(unfetch_module_exports)));
  }
});

// node_modules/@thirdweb-dev/wallets/dist/base-eec23f27.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/wallets/evm/wallets/abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js
init_shim();
init_lib3();
var ERC20WithDecimalsAbi = [{
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "address",
    name: "owner",
    type: "address"
  }, {
    indexed: true,
    internalType: "address",
    name: "spender",
    type: "address"
  }, {
    indexed: false,
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "Approval",
  type: "event"
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "address",
    name: "from",
    type: "address"
  }, {
    indexed: true,
    internalType: "address",
    name: "to",
    type: "address"
  }, {
    indexed: false,
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "Transfer",
  type: "event"
}, {
  inputs: [{
    internalType: "address",
    name: "owner",
    type: "address"
  }, {
    internalType: "address",
    name: "spender",
    type: "address"
  }],
  name: "allowance",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "spender",
    type: "address"
  }, {
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "approve",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "who",
    type: "address"
  }],
  name: "balanceOf",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "totalSupply",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "to",
    type: "address"
  }, {
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "transfer",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "from",
    type: "address"
  }, {
    internalType: "address",
    name: "to",
    type: "address"
  }, {
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "transferFrom",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [],
  name: "decimals",
  outputs: [{
    internalType: "uint8",
    name: "",
    type: "uint8"
  }],
  stateMutability: "view",
  type: "function"
}];
function createErc20(provider, currencyAddress) {
  return new Contract(currencyAddress, ERC20WithDecimalsAbi, provider);
}
function chainIdToThirdwebRpc(chainId, clientId) {
  return `https://${chainId}.rpc.thirdweb.com${clientId ? `/${clientId}` : ""}${typeof globalThis !== "undefined" && "APP_BUNDLE_ID" in globalThis ? `?bundleId=${globalThis.APP_BUNDLE_ID}` : ""}`;
}
var EIP1271_ABI = ["function isValidSignature(bytes32 _message, bytes _signature) public view returns (bytes4)"];
var EIP1271_MAGICVALUE = "0x1626ba7e";
async function checkContractWalletSignature(message, signature, address, chainId) {
  const provider = new lib_exports.JsonRpcProvider(chainIdToThirdwebRpc(chainId));
  const walletContract = new Contract(address, EIP1271_ABI, provider);
  const _hashMessage = utils_exports.hashMessage(message);
  try {
    const res = await walletContract.isValidSignature(_hashMessage, signature);
    return res === EIP1271_MAGICVALUE;
  } catch {
    return false;
  }
}
var AbstractWallet = class extends eventemitter3_default {
  constructor() {
    super(...arguments);
    _defineProperty(this, "type", "evm");
  }
  async getAddress() {
    const signer = await this.getSigner();
    return signer.getAddress();
  }
  async getBalance() {
    let currencyAddress = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : NATIVE_TOKEN_ADDRESS;
    const signer = await this.getSigner();
    const address = await this.getAddress();
    if (!signer.provider) {
      throw new Error("Please connect a provider");
    }
    let balance;
    if (isNativeToken(currencyAddress)) {
      balance = await signer.provider.getBalance(address);
    } else {
      const erc20 = createErc20(signer, currencyAddress);
      balance = await erc20.balanceOf(address);
    }
    return await fetchCurrencyValue(signer.provider, currencyAddress, balance);
  }
  async getChainId() {
    const signer = await this.getSigner();
    return signer.getChainId();
  }
  async transfer(to, amount) {
    let currencyAddress = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NATIVE_TOKEN_ADDRESS;
    const signer = await this.getSigner();
    const from = await this.getAddress();
    if (!signer.provider) {
      throw new Error("Please connect a provider");
    }
    const value = await normalizePriceValue(signer.provider, amount, currencyAddress);
    if (isNativeToken(currencyAddress)) {
      const tx = await signer.sendTransaction({
        from,
        to,
        value
      });
      return {
        receipt: await tx.wait()
      };
    } else {
      const erc20 = createErc20(signer, currencyAddress);
      const tx = await erc20.transfer(to, value);
      return {
        receipt: await tx.wait()
      };
    }
  }
  async signMessage(message) {
    const signer = await this.getSigner();
    return await signer.signMessage(message);
  }
  async verifySignature(message, signature, address, chainId) {
    try {
      const messageHash = utils_exports.hashMessage(message);
      const messageHashBytes = utils_exports.arrayify(messageHash);
      const recoveredAddress = utils_exports.recoverAddress(messageHashBytes, signature);
      if (recoveredAddress === address) {
        return true;
      }
    } catch {
    }
    if (chainId !== void 0) {
      try {
        const isValid = await checkContractWalletSignature(message, signature, address, chainId || 1);
        return isValid;
      } catch {
      }
    }
    return false;
  }
};

// node_modules/@thirdweb-dev/wallets/dist/base-eec23f27.browser.esm.js
var PREFIX = "__TW__";
var AsyncLocalStorage = class {
  constructor(name) {
    this.name = name;
  }
  getItem(key) {
    return new Promise((res) => {
      res(localStorage.getItem(`${PREFIX}/${this.name}/${key}`));
    });
  }
  setItem(key, value) {
    return new Promise((res, rej) => {
      try {
        localStorage.setItem(`${PREFIX}/${this.name}/${key}`, value);
        res();
      } catch (e2) {
        rej(e2);
      }
    });
  }
  removeItem(key) {
    return new Promise((res) => {
      localStorage.removeItem(`${PREFIX}/${this.name}/${key}`);
      res();
    });
  }
};
function createAsyncLocalStorage(name) {
  return new AsyncLocalStorage(name);
}
var DEFAULT_DAPP_META = {
  name: "thirdweb powered dApp",
  url: "https://thirdweb.com",
  description: "thirdweb powered dApp",
  logoUrl: "https://thirdweb.com/favicon.ico",
  isDarkMode: true
};
var walletAnalyticsEnabled = true;
function isWalletAnalyticsEnabled() {
  return walletAnalyticsEnabled;
}
function setWalletAnalyticsEnabled(enabled) {
  walletAnalyticsEnabled = enabled;
}
var ANALYTICS_ENDPOINT = "https://c.thirdweb.com/event";
function track(args) {
  if (!isWalletAnalyticsEnabled()) {
    return;
  }
  const {
    clientId,
    walletType,
    walletAddress,
    source,
    action
  } = args;
  const body = {
    source,
    action,
    walletAddress,
    walletType
  };
  fetch(ANALYTICS_ENDPOINT, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-client-id": clientId
    },
    body: JSON.stringify(body)
  });
}
var _connectParams = /* @__PURE__ */ new WeakMap();
var _connect = /* @__PURE__ */ new WeakSet();
var _trackConnection = /* @__PURE__ */ new WeakSet();
var _subscribeToEvents = /* @__PURE__ */ new WeakSet();
var AbstractClientWallet = class extends AbstractWallet {
  getMeta() {
    return this.constructor.meta;
  }
  constructor(walletId, options) {
    super();
    _classPrivateMethodInitSpec(this, _subscribeToEvents);
    _classPrivateMethodInitSpec(this, _trackConnection);
    _classPrivateMethodInitSpec(this, _connect);
    _classPrivateFieldInitSpec(this, _connectParams, {
      writable: true,
      value: void 0
    });
    this.walletId = walletId;
    this.options = options;
    this.chains = ((options == null ? void 0 : options.chains) || defaultChains).map((c2) => updateChainRPCs(c2, options == null ? void 0 : options.clientId));
    this.dappMetadata = (options == null ? void 0 : options.dappMetadata) || DEFAULT_DAPP_META;
    this.walletStorage = (options == null ? void 0 : options.walletStorage) || createAsyncLocalStorage(this.walletId);
  }
  async autoConnect(connectOptions) {
    const options = connectOptions ? {
      ...connectOptions,
      chainId: void 0
    } : void 0;
    return _classPrivateMethodGet(this, _connect, _connect2).call(this, true, options);
  }
  async connect(connectOptions) {
    _classPrivateFieldSet(this, _connectParams, connectOptions);
    const address = await _classPrivateMethodGet(this, _connect, _connect2).call(this, false, connectOptions);
    if (!address) {
      throw new Error("Failed to connect to the wallet.");
    }
    return address;
  }
  getConnectParams() {
    return _classPrivateFieldGet(this, _connectParams);
  }
  async getSigner() {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    return await connector.getSigner();
  }
  async disconnect() {
    const connector = await this.getConnector();
    if (connector) {
      await connector.disconnect();
      this.emit("disconnect");
      connector.removeAllListeners();
    }
  }
  async switchChain(chainId) {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    if (!connector.switchChain) {
      throw new Error("Wallet does not support switching chains");
    }
    return await connector.switchChain(chainId);
  }
  async updateChains(chains) {
    this.chains = chains.map((c2) => {
      var _a;
      return updateChainRPCs(c2, (_a = this.options) == null ? void 0 : _a.clientId);
    });
    const connector = await this.getConnector();
    connector.updateChains(this.chains);
  }
  getPersonalWallet() {
    return void 0;
  }
};
async function _connect2(isAutoConnect, connectOptions) {
  const connector = await this.getConnector();
  _classPrivateMethodGet(this, _subscribeToEvents, _subscribeToEvents2).call(this, connector);
  const isConnected = await connector.isConnected();
  if (isConnected) {
    const address = await connector.getAddress();
    connector.setupListeners();
    if (connectOptions == null ? void 0 : connectOptions.chainId) {
      await connector.switchChain(connectOptions == null ? void 0 : connectOptions.chainId);
    }
    this.emit("connect", {
      address,
      chainId: await this.getChainId()
    });
    _classPrivateMethodGet(this, _trackConnection, _trackConnection2).call(this, address);
    return address;
  }
  if (isAutoConnect) {
    throw new Error("Failed to auto connect to the wallet.");
  }
  try {
    const address = await connector.connect(connectOptions);
    _classPrivateMethodGet(this, _trackConnection, _trackConnection2).call(this, address);
    return address;
  } catch (error) {
    throw new Error(error.message);
  }
}
function _trackConnection2(address) {
  var _a;
  track({
    clientId: ((_a = this.options) == null ? void 0 : _a.clientId) || "",
    source: "connectWallet",
    action: "connect",
    walletType: this.walletId,
    walletAddress: address
  });
}
async function _subscribeToEvents2(connector) {
  connector.on("connect", (data2) => {
    var _a;
    this.emit("connect", {
      address: data2.account,
      chainId: (_a = data2.chain) == null ? void 0 : _a.id
    });
  });
  connector.on("change", (data2) => {
    var _a;
    this.emit("change", {
      address: data2.account,
      chainId: (_a = data2.chain) == null ? void 0 : _a.id
    });
  });
  connector.on("message", (data2) => {
    this.emit("message", data2);
  });
  connector.on("disconnect", async () => {
    this.emit("disconnect");
  });
  connector.on("error", (error) => this.emit("error", error));
}

// node_modules/@thirdweb-dev/wallets/dist/smart-wallet-87ec1d05.browser.esm.js
init_shim();

// node_modules/@walletconnect/web3wallet/dist/index.es.js
init_shim();

// node_modules/@walletconnect/auth-client/dist/index.es.js
init_shim();
var import_logger = __toESM(require_cjs3());
var import_events = __toESM(require_events());
var import_time = __toESM(require_cjs());
init_lib();
init_lib2();
var import_isomorphic_unfetch = __toESM(require_browser2());
var import_random = __toESM(require_random());
var import_sha256 = __toESM(require_sha256());
var G = class {
  constructor(t) {
    this.client = t;
  }
};
var H = class {
  constructor(t) {
    this.opts = t;
  }
};
var Y = "https://rpc.walletconnect.com/v1";
var R = { wc_authRequest: { req: { ttl: import_time.ONE_DAY, prompt: true, tag: 3e3 }, res: { ttl: import_time.ONE_DAY, prompt: false, tag: 3001 } } };
var U = { min: import_time.FIVE_MINUTES, max: import_time.SEVEN_DAYS };
var $ = "wc";
var Q = 1;
var Z = "auth";
var B = "authClient";
var F = `${$}@${1}:${Z}:`;
var x = `${F}:PUB_KEY`;
function z(r) {
  return r == null ? void 0 : r.split(":");
}
function Ze(r) {
  const t = r && z(r);
  if (t)
    return t[3];
}
function We(r) {
  const t = r && z(r);
  if (t)
    return t[2] + ":" + t[3];
}
function W(r) {
  const t = r && z(r);
  if (t)
    return t.pop();
}
async function et(r, t, e2, i3, n2) {
  switch (e2.t) {
    case "eip191":
      return tt(r, t, e2.s);
    case "eip1271":
      return await rt(r, t, e2.s, i3, n2);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${e2.t}`);
  }
}
function tt(r, t, e2) {
  return recoverAddress(hashMessage(t), e2).toLowerCase() === r.toLowerCase();
}
async function rt(r, t, e2, i3, n2) {
  try {
    const s = "0x1626ba7e", o2 = "0000000000000000000000000000000000000000000000000000000000000040", u3 = "0000000000000000000000000000000000000000000000000000000000000041", a2 = e2.substring(2), c2 = hashMessage(t).substring(2), h3 = s + c2 + o2 + u3 + a2, f3 = await (0, import_isomorphic_unfetch.default)(`${Y}/?chainId=${i3}&projectId=${n2}`, { method: "POST", body: JSON.stringify({ id: it(), jsonrpc: "2.0", method: "eth_call", params: [{ to: r, data: h3 }, "latest"] }) }), { result: p4 } = await f3.json();
    return p4 ? p4.slice(0, s.length).toLowerCase() === s.toLowerCase() : false;
  } catch (s) {
    return console.error("isValidEip1271Signature: ", s), false;
  }
}
function it() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function ee(r) {
  return r.getAll().filter((t) => "requester" in t);
}
function te(r, t) {
  return ee(r).find((e2) => e2.id === t);
}
function nt(r) {
  const t = jt(r.aud), e2 = new RegExp(`${r.domain}`).test(r.aud), i3 = !!r.nonce, n2 = r.type ? r.type === "eip4361" : true, s = r.expiry;
  if (s && !Qt(s, U)) {
    const { message: o2 } = N("MISSING_OR_INVALID", `request() expiry: ${s}. Expiry must be a number (in seconds) between ${U.min} and ${U.max}`);
    throw new Error(o2);
  }
  return !!(t && e2 && i3 && n2);
}
function st(r, t) {
  return !!te(t, r.id);
}
function ot(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r) : new Uint8Array(r);
}
function ut(r, t) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var e2 = new Uint8Array(256), i3 = 0; i3 < e2.length; i3++)
    e2[i3] = 255;
  for (var n2 = 0; n2 < r.length; n2++) {
    var s = r.charAt(n2), o2 = s.charCodeAt(0);
    if (e2[o2] !== 255)
      throw new TypeError(s + " is ambiguous");
    e2[o2] = n2;
  }
  var u3 = r.length, a2 = r.charAt(0), c2 = Math.log(u3) / Math.log(256), h3 = Math.log(256) / Math.log(u3);
  function f3(D5) {
    if (D5 instanceof Uint8Array || (ArrayBuffer.isView(D5) ? D5 = new Uint8Array(D5.buffer, D5.byteOffset, D5.byteLength) : Array.isArray(D5) && (D5 = Uint8Array.from(D5))), !(D5 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (D5.length === 0)
      return "";
    for (var l2 = 0, m3 = 0, E4 = 0, y4 = D5.length; E4 !== y4 && D5[E4] === 0; )
      E4++, l2++;
    for (var w4 = (y4 - E4) * h3 + 1 >>> 0, g5 = new Uint8Array(w4); E4 !== y4; ) {
      for (var C2 = D5[E4], _4 = 0, b4 = w4 - 1; (C2 !== 0 || _4 < m3) && b4 !== -1; b4--, _4++)
        C2 += 256 * g5[b4] >>> 0, g5[b4] = C2 % u3 >>> 0, C2 = C2 / u3 >>> 0;
      if (C2 !== 0)
        throw new Error("Non-zero carry");
      m3 = _4, E4++;
    }
    for (var v2 = w4 - m3; v2 !== w4 && g5[v2] === 0; )
      v2++;
    for (var q4 = a2.repeat(l2); v2 < w4; ++v2)
      q4 += r.charAt(g5[v2]);
    return q4;
  }
  function p4(D5) {
    if (typeof D5 != "string")
      throw new TypeError("Expected String");
    if (D5.length === 0)
      return new Uint8Array();
    var l2 = 0;
    if (D5[l2] !== " ") {
      for (var m3 = 0, E4 = 0; D5[l2] === a2; )
        m3++, l2++;
      for (var y4 = (D5.length - l2) * c2 + 1 >>> 0, w4 = new Uint8Array(y4); D5[l2]; ) {
        var g5 = e2[D5.charCodeAt(l2)];
        if (g5 === 255)
          return;
        for (var C2 = 0, _4 = y4 - 1; (g5 !== 0 || C2 < E4) && _4 !== -1; _4--, C2++)
          g5 += u3 * w4[_4] >>> 0, w4[_4] = g5 % 256 >>> 0, g5 = g5 / 256 >>> 0;
        if (g5 !== 0)
          throw new Error("Non-zero carry");
        E4 = C2, l2++;
      }
      if (D5[l2] !== " ") {
        for (var b4 = y4 - E4; b4 !== y4 && w4[b4] === 0; )
          b4++;
        for (var v2 = new Uint8Array(m3 + (y4 - b4)), q4 = m3; b4 !== y4; )
          v2[q4++] = w4[b4++];
        return v2;
      }
    }
  }
  function A3(D5) {
    var l2 = p4(D5);
    if (l2)
      return l2;
    throw new Error(`Non-${t} character`);
  }
  return { encode: f3, decodeUnsafe: p4, decode: A3 };
}
var at = ut;
var Dt = at;
var re = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
    return r;
  if (r instanceof ArrayBuffer)
    return new Uint8Array(r);
  if (ArrayBuffer.isView(r))
    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ct = (r) => new TextEncoder().encode(r);
var ht = (r) => new TextDecoder().decode(r);
var lt = class {
  constructor(t, e2, i3) {
    this.name = t, this.prefix = e2, this.baseEncode = i3;
  }
  encode(t) {
    if (t instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var dt = class {
  constructor(t, e2, i3) {
    if (this.name = t, this.prefix = e2, e2.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = e2.codePointAt(0), this.baseDecode = i3;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(t) {
    return ie(this, t);
  }
};
var pt = class {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return ie(this, t);
  }
  decode(t) {
    const e2 = t[0], i3 = this.decoders[e2];
    if (i3)
      return i3.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ie = (r, t) => new pt({ ...r.decoders || { [r.prefix]: r }, ...t.decoders || { [t.prefix]: t } });
var ft = class {
  constructor(t, e2, i3, n2) {
    this.name = t, this.prefix = e2, this.baseEncode = i3, this.baseDecode = n2, this.encoder = new lt(t, e2, i3), this.decoder = new dt(t, e2, n2);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
};
var O = ({ name: r, prefix: t, encode: e2, decode: i3 }) => new ft(r, t, e2, i3);
var T = ({ prefix: r, name: t, alphabet: e2 }) => {
  const { encode: i3, decode: n2 } = Dt(e2, t);
  return O({ prefix: r, name: t, encode: i3, decode: (s) => re(n2(s)) });
};
var gt = (r, t, e2, i3) => {
  const n2 = {};
  for (let h3 = 0; h3 < t.length; ++h3)
    n2[t[h3]] = h3;
  let s = r.length;
  for (; r[s - 1] === "="; )
    --s;
  const o2 = new Uint8Array(s * e2 / 8 | 0);
  let u3 = 0, a2 = 0, c2 = 0;
  for (let h3 = 0; h3 < s; ++h3) {
    const f3 = n2[r[h3]];
    if (f3 === void 0)
      throw new SyntaxError(`Non-${i3} character`);
    a2 = a2 << e2 | f3, u3 += e2, u3 >= 8 && (u3 -= 8, o2[c2++] = 255 & a2 >> u3);
  }
  if (u3 >= e2 || 255 & a2 << 8 - u3)
    throw new SyntaxError("Unexpected end of data");
  return o2;
};
var Et = (r, t, e2) => {
  const i3 = t[t.length - 1] === "=", n2 = (1 << e2) - 1;
  let s = "", o2 = 0, u3 = 0;
  for (let a2 = 0; a2 < r.length; ++a2)
    for (u3 = u3 << 8 | r[a2], o2 += 8; o2 > e2; )
      o2 -= e2, s += t[n2 & u3 >> o2];
  if (o2 && (s += t[n2 & u3 << e2 - o2]), i3)
    for (; s.length * e2 & 7; )
      s += "=";
  return s;
};
var d = ({ name: r, prefix: t, bitsPerChar: e2, alphabet: i3 }) => O({ prefix: t, name: r, encode(n2) {
  return Et(n2, i3, e2);
}, decode(n2) {
  return gt(n2, i3, e2, r);
} });
var bt = O({ prefix: "\0", name: "identity", encode: (r) => ht(r), decode: (r) => ct(r) });
var yt = Object.freeze({ __proto__: null, identity: bt });
var wt = d({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Ct = Object.freeze({ __proto__: null, base2: wt });
var mt = d({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var vt = Object.freeze({ __proto__: null, base8: mt });
var At = T({ prefix: "9", name: "base10", alphabet: "0123456789" });
var _t = Object.freeze({ __proto__: null, base10: At });
var xt = d({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Rt = d({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Ft = Object.freeze({ __proto__: null, base16: xt, base16upper: Rt });
var Tt = d({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var It = d({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var qt = d({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Ut = d({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Ot = d({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var St = d({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Pt = d({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var Nt = d({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var $t2 = d({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Bt = Object.freeze({ __proto__: null, base32: Tt, base32upper: It, base32pad: qt, base32padupper: Ut, base32hex: Ot, base32hexupper: St, base32hexpad: Pt, base32hexpadupper: Nt, base32z: $t2 });
var zt = T({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var jt2 = T({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Mt = Object.freeze({ __proto__: null, base36: zt, base36upper: jt2 });
var Lt = T({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Kt = T({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Vt = Object.freeze({ __proto__: null, base58btc: Lt, base58flickr: Kt });
var kt = d({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Jt = d({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Xt = d({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Gt = d({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Ht = Object.freeze({ __proto__: null, base64: kt, base64pad: Jt, base64url: Xt, base64urlpad: Gt });
var ne = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var Yt = ne.reduce((r, t, e2) => (r[e2] = t, r), []);
var Qt2 = ne.reduce((r, t, e2) => (r[t.codePointAt(0)] = e2, r), []);
function Zt(r) {
  return r.reduce((t, e2) => (t += Yt[e2], t), "");
}
function Wt(r) {
  const t = [];
  for (const e2 of r) {
    const i3 = Qt2[e2.codePointAt(0)];
    if (i3 === void 0)
      throw new Error(`Non-base256emoji character: ${e2}`);
    t.push(i3);
  }
  return new Uint8Array(t);
}
var er = O({ prefix: "\u{1F680}", name: "base256emoji", encode: Zt, decode: Wt });
var tr = Object.freeze({ __proto__: null, base256emoji: er });
var rr = oe;
var se = 128;
var ir = 127;
var nr = ~ir;
var sr = Math.pow(2, 31);
function oe(r, t, e2) {
  t = t || [], e2 = e2 || 0;
  for (var i3 = e2; r >= sr; )
    t[e2++] = r & 255 | se, r /= 128;
  for (; r & nr; )
    t[e2++] = r & 255 | se, r >>>= 7;
  return t[e2] = r | 0, oe.bytes = e2 - i3 + 1, t;
}
var or = j;
var ur = 128;
var ue = 127;
function j(r, i3) {
  var e2 = 0, i3 = i3 || 0, n2 = 0, s = i3, o2, u3 = r.length;
  do {
    if (s >= u3)
      throw j.bytes = 0, new RangeError("Could not decode varint");
    o2 = r[s++], e2 += n2 < 28 ? (o2 & ue) << n2 : (o2 & ue) * Math.pow(2, n2), n2 += 7;
  } while (o2 >= ur);
  return j.bytes = s - i3, e2;
}
var ar = Math.pow(2, 7);
var Dr = Math.pow(2, 14);
var cr = Math.pow(2, 21);
var hr = Math.pow(2, 28);
var lr = Math.pow(2, 35);
var dr = Math.pow(2, 42);
var pr = Math.pow(2, 49);
var fr = Math.pow(2, 56);
var gr = Math.pow(2, 63);
var Er = function(r) {
  return r < ar ? 1 : r < Dr ? 2 : r < cr ? 3 : r < hr ? 4 : r < lr ? 5 : r < dr ? 6 : r < pr ? 7 : r < fr ? 8 : r < gr ? 9 : 10;
};
var br = { encode: rr, decode: or, encodingLength: Er };
var ae = br;
var De = (r, t, e2 = 0) => (ae.encode(r, t, e2), t);
var ce = (r) => ae.encodingLength(r);
var M = (r, t) => {
  const e2 = t.byteLength, i3 = ce(r), n2 = i3 + ce(e2), s = new Uint8Array(n2 + e2);
  return De(r, s, 0), De(e2, s, i3), s.set(t, n2), new yr(r, e2, t, s);
};
var yr = class {
  constructor(t, e2, i3, n2) {
    this.code = t, this.size = e2, this.digest = i3, this.bytes = n2;
  }
};
var he = ({ name: r, code: t, encode: e2 }) => new wr(r, t, e2);
var wr = class {
  constructor(t, e2, i3) {
    this.name = t, this.code = e2, this.encode = i3;
  }
  digest(t) {
    if (t instanceof Uint8Array) {
      const e2 = this.encode(t);
      return e2 instanceof Uint8Array ? M(this.code, e2) : e2.then((i3) => M(this.code, i3));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var le = (r) => async (t) => new Uint8Array(await crypto.subtle.digest(r, t));
var Cr = he({ name: "sha2-256", code: 18, encode: le("SHA-256") });
var mr = he({ name: "sha2-512", code: 19, encode: le("SHA-512") });
var vr = Object.freeze({ __proto__: null, sha256: Cr, sha512: mr });
var de = 0;
var Ar = "identity";
var pe = re;
var _r = (r) => M(de, pe(r));
var xr = { code: de, name: Ar, encode: pe, digest: _r };
var Rr = Object.freeze({ __proto__: null, identity: xr });
new TextEncoder(), new TextDecoder();
var fe = { ...yt, ...Ct, ...vt, ..._t, ...Ft, ...Bt, ...Mt, ...Vt, ...Ht, ...tr };
({ ...vr, ...Rr });
function ge(r, t, e2, i3) {
  return { name: r, prefix: t, encoder: { name: r, prefix: t, encode: e2 }, decoder: { decode: i3 } };
}
var Ee = ge("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1)));
var L = ge("ascii", "a", (r) => {
  let t = "a";
  for (let e2 = 0; e2 < r.length; e2++)
    t += String.fromCharCode(r[e2]);
  return t;
}, (r) => {
  r = r.substring(1);
  const t = ot(r.length);
  for (let e2 = 0; e2 < r.length; e2++)
    t[e2] = r.charCodeAt(e2);
  return t;
});
var be = { utf8: Ee, "utf-8": Ee, hex: fe.base16, latin1: L, ascii: L, binary: L, ...fe };
function Fr(r, t = "utf8") {
  const e2 = be[t];
  if (!e2)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r, "utf8") : e2.decoder.decode(`${e2.prefix}${r}`);
}
function Tr(r, t = "utf8") {
  const e2 = be[t];
  if (!e2)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r.buffer, r.byteOffset, r.byteLength).toString("utf8") : e2.encoder.encode(r).substring(1);
}
var ye = "base16";
var we = "utf8";
function K(r) {
  const t = (0, import_sha256.hash)(Fr(r, we));
  return Tr(t, ye);
}
var Or = Object.defineProperty;
var Sr = Object.defineProperties;
var Pr = Object.getOwnPropertyDescriptors;
var Ce = Object.getOwnPropertySymbols;
var Nr = Object.prototype.hasOwnProperty;
var $r = Object.prototype.propertyIsEnumerable;
var me = (r, t, e2) => t in r ? Or(r, t, { enumerable: true, configurable: true, writable: true, value: e2 }) : r[t] = e2;
var I = (r, t) => {
  for (var e2 in t || (t = {}))
    Nr.call(t, e2) && me(r, e2, t[e2]);
  if (Ce)
    for (var e2 of Ce(t))
      $r.call(t, e2) && me(r, e2, t[e2]);
  return r;
};
var V2 = (r, t) => Sr(r, Pr(t));
var Br = class extends G {
  constructor(t) {
    super(t), this.initialized = false, this.name = "authEngine", this.init = () => {
      this.initialized || (this.registerRelayerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(R) }), this.initialized = true);
    }, this.request = async (e2, i3) => {
      if (this.isInitialized(), !nt(e2))
        throw new Error("Invalid request");
      if (i3 != null && i3.topic)
        return await this.requestOnKnownPairing(i3.topic, e2);
      const { chainId: n2, statement: s, aud: o2, domain: u3, nonce: a2, type: c2, exp: h3, nbf: f3 } = e2, { topic: p4, uri: A3 } = await this.client.core.pairing.create();
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: p4, uri: A3 } });
      const D5 = await this.client.core.crypto.generateKeyPair(), l2 = Vn(D5);
      await this.client.authKeys.set(x, { responseTopic: l2, publicKey: D5 }), await this.client.pairingTopics.set(l2, { topic: l2, pairingTopic: p4 }), await this.client.core.relayer.subscribe(l2), this.client.logger.info(`sending request to new pairing topic: ${p4}`);
      const m3 = await this.sendRequest(p4, "wc_authRequest", { payloadParams: { type: c2 != null ? c2 : "eip4361", chainId: n2, statement: s, aud: o2, domain: u3, version: "1", nonce: a2, iat: new Date().toISOString(), exp: h3, nbf: f3 }, requester: { publicKey: D5, metadata: this.client.metadata } }, {}, e2.expiry);
      return this.client.logger.info(`sent request to new pairing topic: ${p4}`), { uri: A3, id: m3 };
    }, this.respond = async (e2, i3) => {
      if (this.isInitialized(), !st(e2, this.client.requests))
        throw new Error("Invalid response");
      const n2 = te(this.client.requests, e2.id);
      if (!n2)
        throw new Error(`Could not find pending auth request with id ${e2.id}`);
      const s = n2.requester.publicKey, o2 = await this.client.core.crypto.generateKeyPair(), u3 = Vn(s), a2 = { type: _, receiverPublicKey: s, senderPublicKey: o2 };
      if ("error" in e2) {
        await this.sendError(n2.id, u3, e2, a2);
        return;
      }
      const c2 = { h: { t: "eip4361" }, p: V2(I({}, n2.cacaoPayload), { iss: i3 }), s: e2.signature };
      await this.sendResult(n2.id, u3, c2, a2), await this.client.core.pairing.activate({ topic: n2.pairingTopic }), await this.client.requests.update(n2.id, I({}, c2));
    }, this.getPendingRequests = () => ee(this.client.requests), this.formatMessage = (e2, i3) => {
      this.client.logger.debug(`formatMessage, cacao is: ${JSON.stringify(e2)}`);
      const n2 = `${e2.domain} wants you to sign in with your Ethereum account:`, s = W(i3), o2 = e2.statement, u3 = `URI: ${e2.aud}`, a2 = `Version: ${e2.version}`, c2 = `Chain ID: ${Ze(i3)}`, h3 = `Nonce: ${e2.nonce}`, f3 = `Issued At: ${e2.iat}`, p4 = e2.exp ? `Expiry: ${e2.exp}` : void 0, A3 = e2.resources && e2.resources.length > 0 ? `Resources:
${e2.resources.map((D5) => `- ${D5}`).join(`
`)}` : void 0;
      return [n2, s, "", o2, "", u3, a2, c2, h3, f3, p4, A3].filter((D5) => D5 != null).join(`
`);
    }, this.setExpiry = async (e2, i3) => {
      this.client.core.pairing.pairings.keys.includes(e2) && await this.client.core.pairing.updateExpiry({ topic: e2, expiry: i3 }), this.client.core.expirer.set(e2, i3);
    }, this.sendRequest = async (e2, i3, n2, s, o2) => {
      const u3 = formatJsonRpcRequest(i3, n2), a2 = await this.client.core.crypto.encode(e2, u3, s), c2 = R[i3].req;
      if (o2 && (c2.ttl = o2), this.client.core.history.set(e2, u3), q()) {
        const h3 = K(JSON.stringify(u3));
        this.client.core.verify.register({ attestationId: h3 });
      }
      return await this.client.core.relayer.publish(e2, a2, V2(I({}, c2), { internal: { throwOnFailedPublish: true } })), u3.id;
    }, this.sendResult = async (e2, i3, n2, s) => {
      const o2 = formatJsonRpcResult(e2, n2), u3 = await this.client.core.crypto.encode(i3, o2, s), a2 = await this.client.core.history.get(i3, e2), c2 = R[a2.request.method].res;
      return await this.client.core.relayer.publish(i3, u3, V2(I({}, c2), { internal: { throwOnFailedPublish: true } })), await this.client.core.history.resolve(o2), o2.id;
    }, this.sendError = async (e2, i3, n2, s) => {
      const o2 = formatJsonRpcError(e2, n2.error), u3 = await this.client.core.crypto.encode(i3, o2, s), a2 = await this.client.core.history.get(i3, e2), c2 = R[a2.request.method].res;
      return await this.client.core.relayer.publish(i3, u3, c2), await this.client.core.history.resolve(o2), o2.id;
    }, this.requestOnKnownPairing = async (e2, i3) => {
      const n2 = this.client.core.pairing.pairings.getAll({ active: true }).find((A3) => A3.topic === e2);
      if (!n2)
        throw new Error(`Could not find pairing for provided topic ${e2}`);
      const { publicKey: s } = this.client.authKeys.get(x), { chainId: o2, statement: u3, aud: a2, domain: c2, nonce: h3, type: f3 } = i3, p4 = await this.sendRequest(n2.topic, "wc_authRequest", { payloadParams: { type: f3 != null ? f3 : "eip4361", chainId: o2, statement: u3, aud: a2, domain: c2, version: "1", nonce: h3, iat: new Date().toISOString() }, requester: { publicKey: s, metadata: this.client.metadata } }, {}, i3.expiry);
      return this.client.logger.info(`sent request to known pairing topic: ${n2.topic}`), { id: p4 };
    }, this.onPairingCreated = (e2) => {
      const i3 = this.getPendingRequests();
      if (i3) {
        const n2 = Object.values(i3).find((s) => s.pairingTopic === e2.topic);
        n2 && this.handleAuthRequest(n2);
      }
    }, this.onRelayEventRequest = (e2) => {
      const { topic: i3, payload: n2 } = e2, s = n2.method;
      switch (s) {
        case "wc_authRequest":
          return this.onAuthRequest(i3, n2);
        default:
          return this.client.logger.info(`Unsupported request method ${s}`);
      }
    }, this.onRelayEventResponse = async (e2) => {
      const { topic: i3, payload: n2 } = e2, s = (await this.client.core.history.get(i3, n2.id)).request.method;
      switch (s) {
        case "wc_authRequest":
          return this.onAuthResponse(i3, n2);
        default:
          return this.client.logger.info(`Unsupported response method ${s}`);
      }
    }, this.onAuthRequest = async (e2, i3) => {
      const { requester: n2, payloadParams: s } = i3.params;
      this.client.logger.info({ type: "onAuthRequest", topic: e2, payload: i3 });
      const o2 = K(JSON.stringify(i3)), u3 = await this.getVerifyContext(o2, this.client.metadata), a2 = { requester: n2, pairingTopic: e2, id: i3.id, cacaoPayload: s, verifyContext: u3 };
      await this.client.requests.set(i3.id, a2), this.handleAuthRequest(a2);
    }, this.handleAuthRequest = async (e2) => {
      const { id: i3, pairingTopic: n2, requester: s, cacaoPayload: o2, verifyContext: u3 } = e2;
      try {
        this.client.emit("auth_request", { id: i3, topic: n2, params: { requester: s, cacaoPayload: o2 }, verifyContext: u3 });
      } catch (a2) {
        await this.sendError(e2.id, e2.pairingTopic, a2), this.client.logger.error(a2);
      }
    }, this.onAuthResponse = async (e2, i3) => {
      const { id: n2 } = i3;
      if (this.client.logger.info({ type: "onAuthResponse", topic: e2, response: i3 }), isJsonRpcResult(i3)) {
        const { pairingTopic: s } = this.client.pairingTopics.get(e2);
        await this.client.core.pairing.activate({ topic: s });
        const { s: o2, p: u3 } = i3.result;
        await this.client.requests.set(n2, I({ id: n2, pairingTopic: s }, i3.result));
        const a2 = this.formatMessage(u3, u3.iss);
        this.client.logger.debug(`reconstructed message:
`, JSON.stringify(a2)), this.client.logger.debug("payload.iss:", u3.iss), this.client.logger.debug("signature:", o2);
        const c2 = W(u3.iss), h3 = We(u3.iss);
        if (!c2)
          throw new Error("Could not derive address from `payload.iss`");
        if (!h3)
          throw new Error("Could not derive chainId from `payload.iss`");
        this.client.logger.debug("walletAddress extracted from `payload.iss`:", c2), await et(c2, a2, o2, h3, this.client.projectId) ? this.client.emit("auth_response", { id: n2, topic: e2, params: i3 }) : this.client.emit("auth_response", { id: n2, topic: e2, params: { message: "Invalid signature", code: -1 } });
      } else
        isJsonRpcError(i3) && this.client.emit("auth_response", { id: n2, topic: e2, params: i3 });
    }, this.getVerifyContext = async (e2, i3) => {
      const n2 = { verified: { verifyUrl: i3.verifyUrl || "", validation: "UNKNOWN", origin: i3.url || "" } };
      try {
        const s = await this.client.core.verify.resolve({ attestationId: e2, verifyUrl: i3.verifyUrl });
        s && (n2.verified.origin = s.origin, n2.verified.isScam = s.isScam, n2.verified.validation = origin === new URL(i3.url).origin ? "VALID" : "INVALID");
      } catch (s) {
        this.client.logger.error(s);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(n2)}`), n2;
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = N("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(D.message, async (t) => {
      const { topic: e2, message: i3 } = t, { responseTopic: n2, publicKey: s } = this.client.authKeys.keys.includes(x) ? this.client.authKeys.get(x) : { responseTopic: void 0, publicKey: void 0 };
      if (n2 && e2 !== n2) {
        this.client.logger.debug("[Auth] Ignoring message from unknown topic", e2);
        return;
      }
      const o2 = await this.client.core.crypto.decode(e2, i3, { receiverPublicKey: s });
      isJsonRpcRequest(o2) ? (this.client.core.history.set(e2, o2), this.onRelayEventRequest({ topic: e2, payload: o2 })) : isJsonRpcResponse(o2) && (await this.client.core.history.resolve(o2), this.onRelayEventResponse({ topic: e2, payload: o2 }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(V.create, (t) => this.onPairingCreated(t));
  }
};
var S = class extends H {
  constructor(t) {
    super(t), this.protocol = $, this.version = Q, this.name = B, this.events = new import_events.EventEmitter(), this.emit = (i3, n2) => this.events.emit(i3, n2), this.on = (i3, n2) => this.events.on(i3, n2), this.once = (i3, n2) => this.events.once(i3, n2), this.off = (i3, n2) => this.events.off(i3, n2), this.removeListener = (i3, n2) => this.events.removeListener(i3, n2), this.request = async (i3, n2) => {
      try {
        return await this.engine.request(i3, n2);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.respond = async (i3, n2) => {
      try {
        return await this.engine.respond(i3, n2);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.getPendingRequests = () => {
      try {
        return this.engine.getPendingRequests();
      } catch (i3) {
        throw this.logger.error(i3.message), i3;
      }
    }, this.formatMessage = (i3, n2) => {
      try {
        return this.engine.formatMessage(i3, n2);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    };
    const e2 = typeof t.logger < "u" && typeof t.logger != "string" ? t.logger : (0, import_logger.pino)((0, import_logger.getDefaultLoggerOptions)({ level: t.logger || "error" }));
    this.name = (t == null ? void 0 : t.name) || B, this.metadata = t.metadata, this.projectId = t.projectId, this.core = t.core || new zr(t), this.logger = (0, import_logger.generateChildLogger)(e2, this.name), this.authKeys = new $t(this.core, this.logger, "authKeys", F, () => x), this.pairingTopics = new $t(this.core, this.logger, "pairingTopics", F), this.requests = new $t(this.core, this.logger, "requests", F, (i3) => i3.id), this.engine = new Br(this);
  }
  static async init(t) {
    const e2 = new S(t);
    return await e2.initialize(), e2;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.authKeys.init(), await this.requests.init(), await this.pairingTopics.init(), await this.engine.init(), this.logger.info("AuthClient Initialization Success"), this.logger.info({ authClient: this });
    } catch (t) {
      throw this.logger.info("AuthClient Initialization Failure"), this.logger.error(t.message), t;
    }
  }
};
var zr2 = S;

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/sign-client/dist/index.es.js
init_shim();

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/core/dist/index.es.js
init_shim();
var import_events4 = __toESM(require_events());
var import_keyvaluestorage = __toESM(require_browser());
var import_heartbeat = __toESM(require_cjs2());
var import_logger2 = __toESM(require_cjs3());

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/types/dist/index.es.js
init_shim();
init_esm();
var import_events3 = __toESM(require_events());
var n = class extends IEvents {
  constructor(s) {
    super(), this.opts = s, this.protocol = "wc", this.version = 2;
  }
};
var h = class extends IEvents {
  constructor(s, t) {
    super(), this.core = s, this.logger = t, this.records = /* @__PURE__ */ new Map();
  }
};
var a = class {
  constructor(s, t) {
    this.logger = s, this.core = t;
  }
};
var u = class extends IEvents {
  constructor(s, t) {
    super(), this.relayer = s, this.logger = t;
  }
};
var g = class extends IEvents {
  constructor(s) {
    super();
  }
};
var p = class {
  constructor(s, t, o2, w4) {
    this.core = s, this.logger = t, this.name = o2;
  }
};
var d2 = class extends IEvents {
  constructor(s, t) {
    super(), this.relayer = s, this.logger = t;
  }
};
var E = class extends IEvents {
  constructor(s, t) {
    super(), this.core = s, this.logger = t;
  }
};
var y = class {
  constructor(s, t) {
    this.projectId = s, this.logger = t;
  }
};
var b = class {
  constructor(s) {
    this.opts = s, this.protocol = "wc", this.version = 2;
  }
};
var S2 = class {
  constructor(s) {
    this.client = s;
  }
};

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/utils/dist/index.es.js
init_shim();
var import_chacha20poly1305 = __toESM(require_chacha20poly1305());
var import_hkdf = __toESM(require_hkdf());
var import_random2 = __toESM(require_random());
var import_sha2562 = __toESM(require_sha256());
var fe2 = __toESM(require_x25519());
var import_time2 = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs4());
var import_window_metadata = __toESM(require_cjs5());
var V3 = __toESM(require_query_string());
function K2(e2, n2) {
  return e2.includes(":") ? [e2] : n2.chains || [];
}
var J = "base10";
var p2 = "base16";
var x2 = "base64pad";
var F2 = "utf8";
var Q2 = 0;
var _2 = 1;
var $n = 0;
var Ie2 = 1;
var Z2 = 12;
var X = 32;
function jn() {
  const e2 = fe2.generateKeyPair();
  return { privateKey: toString(e2.secretKey, p2), publicKey: toString(e2.publicKey, p2) };
}
function Dn() {
  const e2 = (0, import_random2.randomBytes)(X);
  return toString(e2, p2);
}
function kn(e2, n2) {
  const t = fe2.sharedKey(fromString(e2, p2), fromString(n2, p2), true), r = new import_hkdf.HKDF(import_sha2562.SHA256, t).expand(X);
  return toString(r, p2);
}
function Vn2(e2) {
  const n2 = (0, import_sha2562.hash)(fromString(e2, p2));
  return toString(n2, p2);
}
function Mn(e2) {
  const n2 = (0, import_sha2562.hash)(fromString(e2, F2));
  return toString(n2, p2);
}
function Pe(e2) {
  return fromString(`${e2}`, J);
}
function $2(e2) {
  return Number(toString(e2, J));
}
function Kn(e2) {
  const n2 = Pe(typeof e2.type < "u" ? e2.type : Q2);
  if ($2(n2) === _2 && typeof e2.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t = typeof e2.senderPublicKey < "u" ? fromString(e2.senderPublicKey, p2) : void 0, r = typeof e2.iv < "u" ? fromString(e2.iv, p2) : (0, import_random2.randomBytes)(Z2), o2 = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e2.symKey, p2)).seal(r, fromString(e2.message, F2));
  return Te2({ type: n2, sealed: o2, iv: r, senderPublicKey: t });
}
function Ln(e2) {
  const n2 = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e2.symKey, p2)), { sealed: t, iv: r } = ee2(e2.encoded), o2 = n2.open(r, t);
  if (o2 === null)
    throw new Error("Failed to decrypt");
  return toString(o2, F2);
}
function Te2(e2) {
  if ($2(e2.type) === _2) {
    if (typeof e2.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e2.type, e2.senderPublicKey, e2.iv, e2.sealed]), x2);
  }
  return toString(concat([e2.type, e2.iv, e2.sealed]), x2);
}
function ee2(e2) {
  const n2 = fromString(e2, x2), t = n2.slice($n, Ie2), r = Ie2;
  if ($2(t) === _2) {
    const l2 = r + X, d4 = l2 + Z2, c2 = n2.slice(r, l2), u3 = n2.slice(l2, d4), a2 = n2.slice(d4);
    return { type: t, sealed: a2, iv: u3, senderPublicKey: c2 };
  }
  const o2 = r + Z2, s = n2.slice(r, o2), i3 = n2.slice(o2);
  return { type: t, sealed: i3, iv: s };
}
function xn(e2, n2) {
  const t = ee2(e2);
  return Re2({ type: $2(t.type), senderPublicKey: typeof t.senderPublicKey < "u" ? toString(t.senderPublicKey, p2) : void 0, receiverPublicKey: n2 == null ? void 0 : n2.receiverPublicKey });
}
function Re2(e2) {
  const n2 = (e2 == null ? void 0 : e2.type) || Q2;
  if (n2 === _2) {
    if (typeof (e2 == null ? void 0 : e2.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (e2 == null ? void 0 : e2.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: n2, senderPublicKey: e2 == null ? void 0 : e2.senderPublicKey, receiverPublicKey: e2 == null ? void 0 : e2.receiverPublicKey };
}
function Fn(e2) {
  return e2.type === _2 && typeof e2.senderPublicKey == "string" && typeof e2.receiverPublicKey == "string";
}
var Hn = Object.defineProperty;
var Ae = Object.getOwnPropertySymbols;
var qn = Object.prototype.hasOwnProperty;
var Bn = Object.prototype.propertyIsEnumerable;
var Ue = (e2, n2, t) => n2 in e2 ? Hn(e2, n2, { enumerable: true, configurable: true, writable: true, value: t }) : e2[n2] = t;
var _e = (e2, n2) => {
  for (var t in n2 || (n2 = {}))
    qn.call(n2, t) && Ue(e2, t, n2[t]);
  if (Ae)
    for (var t of Ae(n2))
      Bn.call(n2, t) && Ue(e2, t, n2[t]);
  return e2;
};
var Ce2 = "ReactNative";
var m = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var je = "js";
function te2() {
  return typeof import_process.default < "u" && typeof import_process.default.versions < "u" && typeof import_process.default.versions.node < "u";
}
function j2() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === Ce2;
}
function q2() {
  return !te2() && !!(0, import_window_getters.getNavigator)();
}
function R2() {
  return j2() ? m.reactNative : te2() ? m.node : q2() ? m.browser : m.unknown;
}
function De2(e2, n2) {
  let t = V3.parse(e2);
  return t = _e(_e({}, t), n2), e2 = V3.stringify(t), e2;
}
function zn() {
  return (0, import_window_metadata.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function ke2() {
  if (R2() === m.reactNative && typeof _global < "u" && typeof (_global == null ? void 0 : _global.Platform) < "u") {
    const { OS: t, Version: r } = _global.Platform;
    return [t, r].join("-");
  }
  const e2 = detect();
  if (e2 === null)
    return "unknown";
  const n2 = e2.os ? e2.os.replace(" ", "").toLowerCase() : "unknown";
  return e2.type === "browser" ? [n2, e2.name, e2.version].join("-") : [n2, e2.version].join("-");
}
function Ve() {
  var e2;
  const n2 = R2();
  return n2 === m.browser ? [n2, ((e2 = (0, import_window_getters.getLocation)()) == null ? void 0 : e2.host) || "unknown"].join(":") : n2;
}
function Me(e2, n2, t) {
  const r = ke2(), o2 = Ve();
  return [[e2, n2].join("-"), [je, t].join("-"), r, o2].join("/");
}
function Jn({ protocol: e2, version: n2, relayUrl: t, sdkVersion: r, auth: o2, projectId: s, useOnCloseEvent: i3 }) {
  const l2 = t.split("?"), d4 = Me(e2, n2, r), c2 = { auth: o2, ua: d4, projectId: s, useOnCloseEvent: i3 || void 0 }, u3 = De2(l2[1] || "", c2);
  return l2[0] + "?" + u3;
}
function O2(e2, n2) {
  return e2.filter((t) => n2.includes(t)).length === e2.length;
}
function et2(e2) {
  return Object.fromEntries(e2.entries());
}
function nt2(e2) {
  return new Map(Object.entries(e2));
}
function st2(e2 = import_time2.FIVE_MINUTES, n2) {
  const t = (0, import_time2.toMiliseconds)(e2 || import_time2.FIVE_MINUTES);
  let r, o2, s;
  return { resolve: (i3) => {
    s && r && (clearTimeout(s), r(i3));
  }, reject: (i3) => {
    s && o2 && (clearTimeout(s), o2(i3));
  }, done: () => new Promise((i3, l2) => {
    s = setTimeout(() => {
      l2(new Error(n2));
    }, t), r = i3, o2 = l2;
  }) };
}
function it2(e2, n2, t) {
  return new Promise(async (r, o2) => {
    const s = setTimeout(() => o2(new Error(t)), n2);
    try {
      const i3 = await e2;
      r(i3);
    } catch (i3) {
      o2(i3);
    }
    clearTimeout(s);
  });
}
function re2(e2, n2) {
  if (typeof n2 == "string" && n2.startsWith(`${e2}:`))
    return n2;
  if (e2.toLowerCase() === "topic") {
    if (typeof n2 != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n2}`;
  } else if (e2.toLowerCase() === "id") {
    if (typeof n2 != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n2}`;
  }
  throw new Error(`Unknown expirer target type: ${e2}`);
}
function ct2(e2) {
  return re2("topic", e2);
}
function at2(e2) {
  return re2("id", e2);
}
function ut2(e2) {
  const [n2, t] = e2.split(":"), r = { id: void 0, topic: void 0 };
  if (n2 === "topic" && typeof t == "string")
    r.topic = t;
  else if (n2 === "id" && Number.isInteger(Number(t)))
    r.id = Number(t);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${n2}:${t}`);
  return r;
}
function lt2(e2, n2) {
  return (0, import_time2.fromMiliseconds)((n2 || Date.now()) + (0, import_time2.toMiliseconds)(e2));
}
function dt2(e2) {
  return Date.now() >= (0, import_time2.toMiliseconds)(e2);
}
function ft2(e2, n2) {
  return `${e2}${n2 ? `:${n2}` : ""}`;
}
async function pt2({ id: e2, topic: n2, wcDeepLink: t }) {
  try {
    if (!t)
      return;
    const r = typeof t == "string" ? JSON.parse(t) : t;
    let o2 = r == null ? void 0 : r.href;
    if (typeof o2 != "string")
      return;
    o2.endsWith("/") && (o2 = o2.slice(0, -1));
    const s = `${o2}/wc?requestId=${e2}&sessionTopic=${n2}`, i3 = R2();
    i3 === m.browser ? s.startsWith("https://") ? window.open(s, "_blank", "noreferrer noopener") : window.open(s, "_self", "noreferrer noopener") : i3 === m.reactNative && typeof (_global == null ? void 0 : _global.Linking) < "u" && await _global.Linking.openURL(s);
  } catch (r) {
    console.error(r);
  }
}
var Fe2 = "irn";
function mt2(e2) {
  return (e2 == null ? void 0 : e2.relay) || { protocol: Fe2 };
}
function yt2(e2) {
  const n2 = RELAY_JSONRPC[e2];
  if (typeof n2 > "u")
    throw new Error(`Relay Protocol not supported: ${e2}`);
  return n2;
}
var ht2 = Object.defineProperty;
var He = Object.getOwnPropertySymbols;
var vt2 = Object.prototype.hasOwnProperty;
var gt2 = Object.prototype.propertyIsEnumerable;
var qe = (e2, n2, t) => n2 in e2 ? ht2(e2, n2, { enumerable: true, configurable: true, writable: true, value: t }) : e2[n2] = t;
var Et2 = (e2, n2) => {
  for (var t in n2 || (n2 = {}))
    vt2.call(n2, t) && qe(e2, t, n2[t]);
  if (He)
    for (var t of He(n2))
      gt2.call(n2, t) && qe(e2, t, n2[t]);
  return e2;
};
function Be(e2, n2 = "-") {
  const t = {}, r = "relay" + n2;
  return Object.keys(e2).forEach((o2) => {
    if (o2.startsWith(r)) {
      const s = o2.replace(r, ""), i3 = e2[o2];
      t[s] = i3;
    }
  }), t;
}
function bt2(e2) {
  e2 = e2.includes("wc://") ? e2.replace("wc://", "") : e2, e2 = e2.includes("wc:") ? e2.replace("wc:", "") : e2;
  const n2 = e2.indexOf(":"), t = e2.indexOf("?") !== -1 ? e2.indexOf("?") : void 0, r = e2.substring(0, n2), o2 = e2.substring(n2 + 1, t).split("@"), s = typeof t < "u" ? e2.substring(t) : "", i3 = V3.parse(s);
  return { protocol: r, topic: Ge(o2[0]), version: parseInt(o2[1], 10), symKey: i3.symKey, relay: Be(i3) };
}
function Ge(e2) {
  return e2.startsWith("//") ? e2.substring(2) : e2;
}
function We2(e2, n2 = "-") {
  const t = "relay", r = {};
  return Object.keys(e2).forEach((o2) => {
    const s = t + n2 + o2;
    e2[o2] && (r[s] = e2[o2]);
  }), r;
}
function Nt2(e2) {
  return `${e2.protocol}:${e2.topic}@${e2.version}?` + V3.stringify(Et2({ symKey: e2.symKey }, We2(e2.relay)));
}
function A(e2) {
  const n2 = [];
  return e2.forEach((t) => {
    const [r, o2] = t.split(":");
    n2.push(`${r}:${o2}`);
  }), n2;
}
function Je2(e2) {
  const n2 = [];
  return Object.values(e2).forEach((t) => {
    n2.push(...A(t.accounts));
  }), n2;
}
function Qe(e2, n2) {
  const t = [];
  return Object.values(e2).forEach((r) => {
    A(r.accounts).includes(n2) && t.push(...r.methods);
  }), t;
}
function Ze2(e2, n2) {
  const t = [];
  return Object.values(e2).forEach((r) => {
    A(r.accounts).includes(n2) && t.push(...r.events);
  }), t;
}
function At2(e2, n2) {
  const t = cn(e2, n2);
  if (t)
    throw new Error(t.message);
  const r = {};
  for (const [o2, s] of Object.entries(e2))
    r[o2] = { methods: s.methods, events: s.events, chains: s.accounts.map((i3) => `${i3.split(":")[0]}:${i3.split(":")[1]}`) };
  return r;
}
var _t2 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var Ct2 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N3(e2, n2) {
  const { message: t, code: r } = Ct2[e2];
  return { message: n2 ? `${t} ${n2}` : t, code: r };
}
function U2(e2, n2) {
  const { message: t, code: r } = _t2[e2];
  return { message: n2 ? `${t} ${n2}` : t, code: r };
}
function D2(e2, n2) {
  return Array.isArray(e2) ? typeof n2 < "u" && e2.length ? e2.every(n2) : true : false;
}
function B2(e2) {
  return Object.getPrototypeOf(e2) === Object.prototype && Object.keys(e2).length;
}
function w(e2) {
  return typeof e2 > "u";
}
function h2(e2, n2) {
  return n2 && w(e2) ? true : typeof e2 == "string" && !!e2.trim().length;
}
function G2(e2, n2) {
  return n2 && w(e2) ? true : typeof e2 == "number" && !isNaN(e2);
}
function $t3(e2, n2) {
  const { requiredNamespaces: t } = n2, r = Object.keys(e2.namespaces), o2 = Object.keys(t);
  let s = true;
  return O2(o2, r) ? (r.forEach((i3) => {
    const { accounts: l2, methods: d4, events: c2 } = e2.namespaces[i3], u3 = A(l2), a2 = t[i3];
    (!O2(K2(i3, a2), u3) || !O2(a2.methods, d4) || !O2(a2.events, c2)) && (s = false);
  }), s) : false;
}
function k(e2) {
  return h2(e2, false) && e2.includes(":") ? e2.split(":").length === 2 : false;
}
function en(e2) {
  if (h2(e2, false) && e2.includes(":")) {
    const n2 = e2.split(":");
    if (n2.length === 3) {
      const t = n2[0] + ":" + n2[1];
      return !!n2[2] && k(t);
    }
  }
  return false;
}
function jt3(e2) {
  if (h2(e2, false))
    try {
      return typeof new URL(e2) < "u";
    } catch {
      return false;
    }
  return false;
}
function Dt2(e2) {
  var n2;
  return (n2 = e2 == null ? void 0 : e2.proposer) == null ? void 0 : n2.publicKey;
}
function kt2(e2) {
  return e2 == null ? void 0 : e2.topic;
}
function Vt2(e2, n2) {
  let t = null;
  return h2(e2 == null ? void 0 : e2.publicKey, false) || (t = N3("MISSING_OR_INVALID", `${n2} controller public key should be a string`)), t;
}
function ie2(e2) {
  let n2 = true;
  return D2(e2) ? e2.length && (n2 = e2.every((t) => h2(t, false))) : n2 = false, n2;
}
function nn(e2, n2, t) {
  let r = null;
  return D2(n2) && n2.length ? n2.forEach((o2) => {
    r || k(o2) || (r = U2("UNSUPPORTED_CHAINS", `${t}, chain ${o2} should be a string and conform to "namespace:chainId" format`));
  }) : k(e2) || (r = U2("UNSUPPORTED_CHAINS", `${t}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r;
}
function tn(e2, n2, t) {
  let r = null;
  return Object.entries(e2).forEach(([o2, s]) => {
    if (r)
      return;
    const i3 = nn(o2, K2(o2, s), `${n2} ${t}`);
    i3 && (r = i3);
  }), r;
}
function rn(e2, n2) {
  let t = null;
  return D2(e2) ? e2.forEach((r) => {
    t || en(r) || (t = U2("UNSUPPORTED_ACCOUNTS", `${n2}, account ${r} should be a string and conform to "namespace:chainId:address" format`));
  }) : t = U2("UNSUPPORTED_ACCOUNTS", `${n2}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t;
}
function on(e2, n2) {
  let t = null;
  return Object.values(e2).forEach((r) => {
    if (t)
      return;
    const o2 = rn(r == null ? void 0 : r.accounts, `${n2} namespace`);
    o2 && (t = o2);
  }), t;
}
function sn(e2, n2) {
  let t = null;
  return ie2(e2 == null ? void 0 : e2.methods) ? ie2(e2 == null ? void 0 : e2.events) || (t = U2("UNSUPPORTED_EVENTS", `${n2}, events should be an array of strings or empty array for no events`)) : t = U2("UNSUPPORTED_METHODS", `${n2}, methods should be an array of strings or empty array for no methods`), t;
}
function ce2(e2, n2) {
  let t = null;
  return Object.values(e2).forEach((r) => {
    if (t)
      return;
    const o2 = sn(r, `${n2}, namespace`);
    o2 && (t = o2);
  }), t;
}
function Mt2(e2, n2, t) {
  let r = null;
  if (e2 && B2(e2)) {
    const o2 = ce2(e2, n2);
    o2 && (r = o2);
    const s = tn(e2, n2, t);
    s && (r = s);
  } else
    r = N3("MISSING_OR_INVALID", `${n2}, ${t} should be an object with data`);
  return r;
}
function cn(e2, n2) {
  let t = null;
  if (e2 && B2(e2)) {
    const r = ce2(e2, n2);
    r && (t = r);
    const o2 = on(e2, n2);
    o2 && (t = o2);
  } else
    t = N3("MISSING_OR_INVALID", `${n2}, namespaces should be an object with data`);
  return t;
}
function an(e2) {
  return h2(e2.protocol, true);
}
function Kt2(e2, n2) {
  let t = false;
  return n2 && !e2 ? t = true : e2 && D2(e2) && e2.length && e2.forEach((r) => {
    t = an(r);
  }), t;
}
function Lt2(e2) {
  return typeof e2 == "number";
}
function xt2(e2) {
  return typeof e2 < "u" && typeof e2 !== null;
}
function Ft2(e2) {
  return !(!e2 || typeof e2 != "object" || !e2.code || !G2(e2.code, false) || !e2.message || !h2(e2.message, false));
}
function Ht2(e2) {
  return !(w(e2) || !h2(e2.method, false));
}
function qt2(e2) {
  return !(w(e2) || w(e2.result) && w(e2.error) || !G2(e2.id, false) || !h2(e2.jsonrpc, false));
}
function Bt2(e2) {
  return !(w(e2) || !h2(e2.name, false));
}
function Gt2(e2, n2) {
  return !(!k(n2) || !Je2(e2).includes(n2));
}
function Wt2(e2, n2, t) {
  return h2(t, false) ? Qe(e2, n2).includes(t) : false;
}
function zt2(e2, n2, t) {
  return h2(t, false) ? Ze2(e2, n2).includes(t) : false;
}
function un(e2, n2, t) {
  let r = null;
  const o2 = Yt2(e2), s = Jt2(n2), i3 = Object.keys(o2), l2 = Object.keys(s), d4 = ln(Object.keys(e2)), c2 = ln(Object.keys(n2)), u3 = d4.filter((a2) => !c2.includes(a2));
  return u3.length && (r = N3("NON_CONFORMING_NAMESPACES", `${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u3.toString()}
      Received: ${Object.keys(n2).toString()}`)), O2(i3, l2) || (r = N3("NON_CONFORMING_NAMESPACES", `${t} namespaces chains don't satisfy required namespaces.
      Required: ${i3.toString()}
      Approved: ${l2.toString()}`)), Object.keys(n2).forEach((a2) => {
    if (!a2.includes(":") || r)
      return;
    const b4 = A(n2[a2].accounts);
    b4.includes(a2) || (r = N3("NON_CONFORMING_NAMESPACES", `${t} namespaces accounts don't satisfy namespace accounts for ${a2}
        Required: ${a2}
        Approved: ${b4.toString()}`));
  }), i3.forEach((a2) => {
    r || (O2(o2[a2].methods, s[a2].methods) ? O2(o2[a2].events, s[a2].events) || (r = N3("NON_CONFORMING_NAMESPACES", `${t} namespaces events don't satisfy namespace events for ${a2}`)) : r = N3("NON_CONFORMING_NAMESPACES", `${t} namespaces methods don't satisfy namespace methods for ${a2}`));
  }), r;
}
function Yt2(e2) {
  const n2 = {};
  return Object.keys(e2).forEach((t) => {
    var r;
    t.includes(":") ? n2[t] = e2[t] : (r = e2[t].chains) == null || r.forEach((o2) => {
      n2[o2] = { methods: e2[t].methods, events: e2[t].events };
    });
  }), n2;
}
function ln(e2) {
  return [...new Set(e2.map((n2) => n2.includes(":") ? n2.split(":")[0] : n2))];
}
function Jt2(e2) {
  const n2 = {};
  return Object.keys(e2).forEach((t) => {
    if (t.includes(":"))
      n2[t] = e2[t];
    else {
      const r = A(e2[t].accounts);
      r == null ? void 0 : r.forEach((o2) => {
        n2[o2] = { accounts: e2[t].accounts.filter((s) => s.includes(`${o2}:`)), methods: e2[t].methods, events: e2[t].events };
      });
    }
  }), n2;
}
function Qt3(e2, n2) {
  return G2(e2, false) && e2 <= n2.max && e2 >= n2.min;
}
function Zt2() {
  const e2 = R2();
  return new Promise((n2) => {
    switch (e2) {
      case m.browser:
        n2(dn());
        break;
      case m.reactNative:
        n2(fn());
        break;
      case m.node:
        n2(pn());
        break;
      default:
        n2(true);
    }
  });
}
function dn() {
  return q2() && (navigator == null ? void 0 : navigator.onLine);
}
async function fn() {
  if (j2() && typeof _global < "u" && _global != null && _global.NetInfo) {
    const e2 = await (_global == null ? void 0 : _global.NetInfo.fetch());
    return e2 == null ? void 0 : e2.isConnected;
  }
  return true;
}
function pn() {
  return true;
}
function Xt2(e2) {
  switch (R2()) {
    case m.browser:
      mn(e2);
      break;
    case m.reactNative:
      yn(e2);
      break;
    case m.node:
      break;
  }
}
function mn(e2) {
  !j2() && q2() && (window.addEventListener("online", () => e2(true)), window.addEventListener("offline", () => e2(false)));
}
function yn(e2) {
  var _a;
  j2() && typeof _global < "u" && _global != null && _global.NetInfo && ((_a = _global) == null ? void 0 : _a.NetInfo.addEventListener((n2) => e2(n2 == null ? void 0 : n2.isConnected)));
}
var ae2 = {};
var er2 = class {
  static get(n2) {
    return ae2[n2];
  }
  static set(n2, t) {
    ae2[n2] = t;
  }
  static delete(n2) {
    delete ae2[n2];
  }
};

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/core/dist/index.es.js
var import_time3 = __toESM(require_cjs());
var import_lodash = __toESM(require_lodash());
function Bi(r, e2) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i3 = 0; i3 < t.length; i3++)
    t[i3] = 255;
  for (var s = 0; s < r.length; s++) {
    var n2 = r.charAt(s), a2 = n2.charCodeAt(0);
    if (t[a2] !== 255)
      throw new TypeError(n2 + " is ambiguous");
    t[a2] = s;
  }
  var o2 = r.length, h3 = r.charAt(0), u3 = Math.log(o2) / Math.log(256), d4 = Math.log(256) / Math.log(o2);
  function p4(c2) {
    if (c2 instanceof Uint8Array || (ArrayBuffer.isView(c2) ? c2 = new Uint8Array(c2.buffer, c2.byteOffset, c2.byteLength) : Array.isArray(c2) && (c2 = Uint8Array.from(c2))), !(c2 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (c2.length === 0)
      return "";
    for (var m3 = 0, z3 = 0, I4 = 0, _4 = c2.length; I4 !== _4 && c2[I4] === 0; )
      I4++, m3++;
    for (var S4 = (_4 - I4) * d4 + 1 >>> 0, b4 = new Uint8Array(S4); I4 !== _4; ) {
      for (var T3 = c2[I4], A3 = 0, C2 = S4 - 1; (T3 !== 0 || A3 < z3) && C2 !== -1; C2--, A3++)
        T3 += 256 * b4[C2] >>> 0, b4[C2] = T3 % o2 >>> 0, T3 = T3 / o2 >>> 0;
      if (T3 !== 0)
        throw new Error("Non-zero carry");
      z3 = A3, I4++;
    }
    for (var x4 = S4 - z3; x4 !== S4 && b4[x4] === 0; )
      x4++;
    for (var j4 = h3.repeat(m3); x4 < S4; ++x4)
      j4 += r.charAt(b4[x4]);
    return j4;
  }
  function y4(c2) {
    if (typeof c2 != "string")
      throw new TypeError("Expected String");
    if (c2.length === 0)
      return new Uint8Array();
    var m3 = 0;
    if (c2[m3] !== " ") {
      for (var z3 = 0, I4 = 0; c2[m3] === h3; )
        z3++, m3++;
      for (var _4 = (c2.length - m3) * u3 + 1 >>> 0, S4 = new Uint8Array(_4); c2[m3]; ) {
        var b4 = t[c2.charCodeAt(m3)];
        if (b4 === 255)
          return;
        for (var T3 = 0, A3 = _4 - 1; (b4 !== 0 || T3 < I4) && A3 !== -1; A3--, T3++)
          b4 += o2 * S4[A3] >>> 0, S4[A3] = b4 % 256 >>> 0, b4 = b4 / 256 >>> 0;
        if (b4 !== 0)
          throw new Error("Non-zero carry");
        I4 = T3, m3++;
      }
      if (c2[m3] !== " ") {
        for (var C2 = _4 - I4; C2 !== _4 && S4[C2] === 0; )
          C2++;
        for (var x4 = new Uint8Array(z3 + (_4 - C2)), j4 = z3; C2 !== _4; )
          x4[j4++] = S4[C2++];
        return x4;
      }
    }
  }
  function M4(c2) {
    var m3 = y4(c2);
    if (m3)
      return m3;
    throw new Error(`Non-${e2} character`);
  }
  return { encode: p4, decodeUnsafe: y4, decode: M4 };
}
var Vi = Bi;
var qi = Vi;
var ze = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
    return r;
  if (r instanceof ArrayBuffer)
    return new Uint8Array(r);
  if (ArrayBuffer.isView(r))
    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ji = (r) => new TextEncoder().encode(r);
var Yi = (r) => new TextDecoder().decode(r);
var Gi = class {
  constructor(e2, t, i3) {
    this.name = e2, this.prefix = t, this.baseEncode = i3;
  }
  encode(e2) {
    if (e2 instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e2)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var Hi = class {
  constructor(e2, t, i3) {
    if (this.name = e2, this.prefix = t, t.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i3;
  }
  decode(e2) {
    if (typeof e2 == "string") {
      if (e2.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e2.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e2) {
    return Ne(this, e2);
  }
};
var Ji = class {
  constructor(e2) {
    this.decoders = e2;
  }
  or(e2) {
    return Ne(this, e2);
  }
  decode(e2) {
    const t = e2[0], i3 = this.decoders[t];
    if (i3)
      return i3.decode(e2);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e2)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var Ne = (r, e2) => new Ji({ ...r.decoders || { [r.prefix]: r }, ...e2.decoders || { [e2.prefix]: e2 } });
var Wi = class {
  constructor(e2, t, i3, s) {
    this.name = e2, this.prefix = t, this.baseEncode = i3, this.baseDecode = s, this.encoder = new Gi(e2, t, i3), this.decoder = new Hi(e2, t, s);
  }
  encode(e2) {
    return this.encoder.encode(e2);
  }
  decode(e2) {
    return this.decoder.decode(e2);
  }
};
var X2 = ({ name: r, prefix: e2, encode: t, decode: i3 }) => new Wi(r, e2, t, i3);
var B3 = ({ prefix: r, name: e2, alphabet: t }) => {
  const { encode: i3, decode: s } = qi(t, e2);
  return X2({ prefix: r, name: e2, encode: i3, decode: (n2) => ze(s(n2)) });
};
var Xi = (r, e2, t, i3) => {
  const s = {};
  for (let d4 = 0; d4 < e2.length; ++d4)
    s[e2[d4]] = d4;
  let n2 = r.length;
  for (; r[n2 - 1] === "="; )
    --n2;
  const a2 = new Uint8Array(n2 * t / 8 | 0);
  let o2 = 0, h3 = 0, u3 = 0;
  for (let d4 = 0; d4 < n2; ++d4) {
    const p4 = s[r[d4]];
    if (p4 === void 0)
      throw new SyntaxError(`Non-${i3} character`);
    h3 = h3 << t | p4, o2 += t, o2 >= 8 && (o2 -= 8, a2[u3++] = 255 & h3 >> o2);
  }
  if (o2 >= t || 255 & h3 << 8 - o2)
    throw new SyntaxError("Unexpected end of data");
  return a2;
};
var Qi = (r, e2, t) => {
  const i3 = e2[e2.length - 1] === "=", s = (1 << t) - 1;
  let n2 = "", a2 = 0, o2 = 0;
  for (let h3 = 0; h3 < r.length; ++h3)
    for (o2 = o2 << 8 | r[h3], a2 += 8; a2 > t; )
      a2 -= t, n2 += e2[s & o2 >> a2];
  if (a2 && (n2 += e2[s & o2 << t - a2]), i3)
    for (; n2.length * t & 7; )
      n2 += "=";
  return n2;
};
var g2 = ({ name: r, prefix: e2, bitsPerChar: t, alphabet: i3 }) => X2({ prefix: e2, name: r, encode(s) {
  return Qi(s, i3, t);
}, decode(s) {
  return Xi(s, i3, t, r);
} });
var Zi = X2({ prefix: "\0", name: "identity", encode: (r) => Yi(r), decode: (r) => ji(r) });
var es = Object.freeze({ __proto__: null, identity: Zi });
var ts = g2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var is = Object.freeze({ __proto__: null, base2: ts });
var ss = g2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var rs = Object.freeze({ __proto__: null, base8: ss });
var ns = B3({ prefix: "9", name: "base10", alphabet: "0123456789" });
var as = Object.freeze({ __proto__: null, base10: ns });
var os = g2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var hs = g2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var cs = Object.freeze({ __proto__: null, base16: os, base16upper: hs });
var us = g2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var ls = g2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var ds = g2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var gs = g2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var ps = g2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var Ds = g2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var ys = g2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var ms = g2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var bs = g2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var fs = Object.freeze({ __proto__: null, base32: us, base32upper: ls, base32pad: ds, base32padupper: gs, base32hex: ps, base32hexupper: Ds, base32hexpad: ys, base32hexpadupper: ms, base32z: bs });
var Es = B3({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var ws = B3({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var vs = Object.freeze({ __proto__: null, base36: Es, base36upper: ws });
var Is = B3({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Cs = B3({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Rs = Object.freeze({ __proto__: null, base58btc: Is, base58flickr: Cs });
var _s = g2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Ss = g2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Ts = g2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Ps = g2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var xs = Object.freeze({ __proto__: null, base64: _s, base64pad: Ss, base64url: Ts, base64urlpad: Ps });
var Ue2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var Os = Ue2.reduce((r, e2, t) => (r[t] = e2, r), []);
var As = Ue2.reduce((r, e2, t) => (r[e2.codePointAt(0)] = t, r), []);
function zs(r) {
  return r.reduce((e2, t) => (e2 += Os[t], e2), "");
}
function Ns(r) {
  const e2 = [];
  for (const t of r) {
    const i3 = As[t.codePointAt(0)];
    if (i3 === void 0)
      throw new Error(`Non-base256emoji character: ${t}`);
    e2.push(i3);
  }
  return new Uint8Array(e2);
}
var Us = X2({ prefix: "\u{1F680}", name: "base256emoji", encode: zs, decode: Ns });
var Ls = Object.freeze({ __proto__: null, base256emoji: Us });
var Fs = Fe3;
var Le2 = 128;
var $s = 127;
var Ms = ~$s;
var ks = Math.pow(2, 31);
function Fe3(r, e2, t) {
  e2 = e2 || [], t = t || 0;
  for (var i3 = t; r >= ks; )
    e2[t++] = r & 255 | Le2, r /= 128;
  for (; r & Ms; )
    e2[t++] = r & 255 | Le2, r >>>= 7;
  return e2[t] = r | 0, Fe3.bytes = t - i3 + 1, e2;
}
var Ks = he3;
var Bs = 128;
var $e = 127;
function he3(r, i3) {
  var t = 0, i3 = i3 || 0, s = 0, n2 = i3, a2, o2 = r.length;
  do {
    if (n2 >= o2)
      throw he3.bytes = 0, new RangeError("Could not decode varint");
    a2 = r[n2++], t += s < 28 ? (a2 & $e) << s : (a2 & $e) * Math.pow(2, s), s += 7;
  } while (a2 >= Bs);
  return he3.bytes = n2 - i3, t;
}
var Vs = Math.pow(2, 7);
var qs = Math.pow(2, 14);
var js = Math.pow(2, 21);
var Ys = Math.pow(2, 28);
var Gs = Math.pow(2, 35);
var Hs = Math.pow(2, 42);
var Js = Math.pow(2, 49);
var Ws = Math.pow(2, 56);
var Xs = Math.pow(2, 63);
var Qs = function(r) {
  return r < Vs ? 1 : r < qs ? 2 : r < js ? 3 : r < Ys ? 4 : r < Gs ? 5 : r < Hs ? 6 : r < Js ? 7 : r < Ws ? 8 : r < Xs ? 9 : 10;
};
var Zs = { encode: Fs, decode: Ks, encodingLength: Qs };
var Me2 = Zs;
var ke3 = (r, e2, t = 0) => (Me2.encode(r, e2, t), e2);
var Ke2 = (r) => Me2.encodingLength(r);
var ce3 = (r, e2) => {
  const t = e2.byteLength, i3 = Ke2(r), s = i3 + Ke2(t), n2 = new Uint8Array(s + t);
  return ke3(r, n2, 0), ke3(t, n2, i3), n2.set(e2, s), new er3(r, t, e2, n2);
};
var er3 = class {
  constructor(e2, t, i3, s) {
    this.code = e2, this.size = t, this.digest = i3, this.bytes = s;
  }
};
var Be2 = ({ name: r, code: e2, encode: t }) => new tr2(r, e2, t);
var tr2 = class {
  constructor(e2, t, i3) {
    this.name = e2, this.code = t, this.encode = i3;
  }
  digest(e2) {
    if (e2 instanceof Uint8Array) {
      const t = this.encode(e2);
      return t instanceof Uint8Array ? ce3(this.code, t) : t.then((i3) => ce3(this.code, i3));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var Ve2 = (r) => async (e2) => new Uint8Array(await crypto.subtle.digest(r, e2));
var ir2 = Be2({ name: "sha2-256", code: 18, encode: Ve2("SHA-256") });
var sr2 = Be2({ name: "sha2-512", code: 19, encode: Ve2("SHA-512") });
var rr2 = Object.freeze({ __proto__: null, sha256: ir2, sha512: sr2 });
var qe2 = 0;
var nr2 = "identity";
var je2 = ze;
var ar2 = (r) => ce3(qe2, je2(r));
var or2 = { code: qe2, name: nr2, encode: je2, digest: ar2 };
var hr2 = Object.freeze({ __proto__: null, identity: or2 });
new TextEncoder(), new TextDecoder();
var Ye = { ...es, ...is, ...rs, ...as, ...cs, ...fs, ...vs, ...Rs, ...xs, ...Ls };
({ ...rr2, ...hr2 });
function Ge2(r) {
  return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;
}
function cr2(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Ge2(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);
}
function He2(r, e2, t, i3) {
  return { name: r, prefix: e2, encoder: { name: r, prefix: e2, encode: t }, decoder: { decode: i3 } };
}
var Je3 = He2("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1)));
var ue3 = He2("ascii", "a", (r) => {
  let e2 = "a";
  for (let t = 0; t < r.length; t++)
    e2 += String.fromCharCode(r[t]);
  return e2;
}, (r) => {
  r = r.substring(1);
  const e2 = cr2(r.length);
  for (let t = 0; t < r.length; t++)
    e2[t] = r.charCodeAt(t);
  return e2;
});
var ur2 = { utf8: Je3, "utf-8": Je3, hex: Ye.base16, latin1: ue3, ascii: ue3, binary: ue3, ...Ye };
function lr2(r, e2 = "utf8") {
  const t = ur2[e2];
  if (!t)
    throw new Error(`Unsupported encoding "${e2}"`);
  return (e2 === "utf8" || e2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Ge2(globalThis.Buffer.from(r, "utf-8")) : t.decoder.decode(`${t.prefix}${r}`);
}
var le3 = "wc";
var We3 = 2;
var Q3 = "core";
var O3 = `${le3}@2:${Q3}:`;
var Xe2 = { name: Q3, logger: "error" };
var Qe2 = { database: ":memory:" };
var Ze3 = "crypto";
var de3 = "client_ed25519_seed";
var et3 = import_time3.ONE_DAY;
var tt2 = "keychain";
var it3 = "0.3";
var st3 = "messages";
var rt2 = "0.3";
var nt3 = import_time3.SIX_HOURS;
var at3 = "publisher";
var ot2 = "irn";
var ht3 = "error";
var ge2 = "wss://relay.walletconnect.com";
var pe2 = "wss://relay.walletconnect.org";
var ct3 = "relayer";
var D3 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var ut3 = "_subscription";
var P = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var lt3 = import_time3.ONE_SECOND;
var dt3 = "2.10.3";
var gt3 = 1e4;
var pt3 = "0.3";
var Dt3 = "WALLETCONNECT_CLIENT_ID";
var w2 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var yt3 = "subscription";
var mt3 = "0.3";
var bt3 = import_time3.FIVE_SECONDS * 1e3;
var ft3 = "pairing";
var Et3 = "0.3";
var F3 = { wc_pairingDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 } } };
var V4 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var R3 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var wt2 = "history";
var vt3 = "0.3";
var It2 = "expirer";
var v = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var Ct3 = "0.3";
var Z3 = "verify-api";
var $3 = "https://verify.walletconnect.com";
var ee3 = "https://verify.walletconnect.org";
var Rt2 = [$3, ee3];
var _t3 = class {
  constructor(e2, t) {
    this.core = e2, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = tt2, this.version = it3, this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      if (!this.initialized) {
        const i3 = await this.getKeyChain();
        typeof i3 < "u" && (this.keychain = i3), this.initialized = true;
      }
    }, this.has = (i3) => (this.isInitialized(), this.keychain.has(i3)), this.set = async (i3, s) => {
      this.isInitialized(), this.keychain.set(i3, s), await this.persist();
    }, this.get = (i3) => {
      this.isInitialized();
      const s = this.keychain.get(i3);
      if (typeof s > "u") {
        const { message: n2 } = N3("NO_MATCHING_KEY", `${this.name}: ${i3}`);
        throw new Error(n2);
      }
      return s;
    }, this.del = async (i3) => {
      this.isInitialized(), this.keychain.delete(i3), await this.persist();
    }, this.core = e2, this.logger = (0, import_logger2.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e2) {
    await this.core.storage.setItem(this.storageKey, et2(e2));
  }
  async getKeyChain() {
    const e2 = await this.core.storage.getItem(this.storageKey);
    return typeof e2 < "u" ? nt2(e2) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N3("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var St2 = class {
  constructor(e2, t, i3) {
    this.core = e2, this.logger = t, this.name = Ze3, this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (s) => (this.isInitialized(), this.keychain.has(s)), this.getClientId = async () => {
      this.isInitialized();
      const s = await this.getClientSeed(), n2 = generateKeyPair(s);
      return encodeIss(n2.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const s = jn();
      return this.setPrivateKey(s.publicKey, s.privateKey);
    }, this.signJWT = async (s) => {
      this.isInitialized();
      const n2 = await this.getClientSeed(), a2 = generateKeyPair(n2), o2 = Dn(), h3 = et3;
      return await signJWT(o2, s, h3, a2);
    }, this.generateSharedKey = (s, n2, a2) => {
      this.isInitialized();
      const o2 = this.getPrivateKey(s), h3 = kn(o2, n2);
      return this.setSymKey(h3, a2);
    }, this.setSymKey = async (s, n2) => {
      this.isInitialized();
      const a2 = n2 || Vn2(s);
      return await this.keychain.set(a2, s), a2;
    }, this.deleteKeyPair = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.deleteSymKey = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.encode = async (s, n2, a2) => {
      this.isInitialized();
      const o2 = Re2(a2), h3 = safeJsonStringify(n2);
      if (Fn(o2)) {
        const y4 = o2.senderPublicKey, M4 = o2.receiverPublicKey;
        s = await this.generateSharedKey(y4, M4);
      }
      const u3 = this.getSymKey(s), { type: d4, senderPublicKey: p4 } = o2;
      return Kn({ type: d4, symKey: u3, message: h3, senderPublicKey: p4 });
    }, this.decode = async (s, n2, a2) => {
      this.isInitialized();
      const o2 = xn(n2, a2);
      if (Fn(o2)) {
        const h3 = o2.receiverPublicKey, u3 = o2.senderPublicKey;
        s = await this.generateSharedKey(h3, u3);
      }
      try {
        const h3 = this.getSymKey(s), u3 = Ln({ symKey: h3, encoded: n2 });
        return safeJsonParse(u3);
      } catch (h3) {
        this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`), this.logger.error(h3);
      }
    }, this.getPayloadType = (s) => {
      const n2 = ee2(s);
      return $2(n2.type);
    }, this.getPayloadSenderPublicKey = (s) => {
      const n2 = ee2(s);
      return n2.senderPublicKey ? toString(n2.senderPublicKey, p2) : void 0;
    }, this.core = e2, this.logger = (0, import_logger2.generateChildLogger)(t, this.name), this.keychain = i3 || new _t3(this.core, this.logger);
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  async setPrivateKey(e2, t) {
    return await this.keychain.set(e2, t), e2;
  }
  getPrivateKey(e2) {
    return this.keychain.get(e2);
  }
  async getClientSeed() {
    let e2 = "";
    try {
      e2 = this.keychain.get(de3);
    } catch {
      e2 = Dn(), await this.keychain.set(de3, e2);
    }
    return lr2(e2, "base16");
  }
  getSymKey(e2) {
    return this.keychain.get(e2);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N3("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var Tt2 = class extends a {
  constructor(e2, t) {
    super(e2, t), this.logger = e2, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = st3, this.version = rt2, this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i3 = await this.getRelayerMessages();
          typeof i3 < "u" && (this.messages = i3), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i3) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i3);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (i3, s) => {
      this.isInitialized();
      const n2 = Mn(s);
      let a2 = this.messages.get(i3);
      return typeof a2 > "u" && (a2 = {}), typeof a2[n2] < "u" || (a2[n2] = s, this.messages.set(i3, a2), await this.persist()), n2;
    }, this.get = (i3) => {
      this.isInitialized();
      let s = this.messages.get(i3);
      return typeof s > "u" && (s = {}), s;
    }, this.has = (i3, s) => {
      this.isInitialized();
      const n2 = this.get(i3), a2 = Mn(s);
      return typeof n2[a2] < "u";
    }, this.del = async (i3) => {
      this.isInitialized(), this.messages.delete(i3), await this.persist();
    }, this.logger = (0, import_logger2.generateChildLogger)(e2, this.name), this.core = t;
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e2) {
    await this.core.storage.setItem(this.storageKey, et2(e2));
  }
  async getRelayerMessages() {
    const e2 = await this.core.storage.getItem(this.storageKey);
    return typeof e2 < "u" ? nt2(e2) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N3("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var yr2 = class extends u {
  constructor(e2, t) {
    super(e2, t), this.relayer = e2, this.logger = t, this.events = new import_events4.EventEmitter(), this.name = at3, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = (0, import_time3.toMiliseconds)(import_time3.TEN_SECONDS), this.needsTransportRestart = false, this.publish = async (i3, s, n2) => {
      var a2;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i3, message: s, opts: n2 } });
      try {
        const o2 = (n2 == null ? void 0 : n2.ttl) || nt3, h3 = mt2(n2), u3 = (n2 == null ? void 0 : n2.prompt) || false, d4 = (n2 == null ? void 0 : n2.tag) || 0, p4 = (n2 == null ? void 0 : n2.id) || getBigIntRpcId().toString(), y4 = { topic: i3, message: s, opts: { ttl: o2, relay: h3, prompt: u3, tag: d4, id: p4 } }, M4 = setTimeout(() => this.queue.set(p4, y4), this.publishTimeout);
        try {
          await await it2(this.rpcPublish(i3, s, o2, h3, u3, d4, p4), this.publishTimeout, "Failed to publish payload, please try again."), this.removeRequestFromQueue(p4), this.relayer.events.emit(D3.publish, y4);
        } catch (c2) {
          if (this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = true, (a2 = n2 == null ? void 0 : n2.internal) != null && a2.throwOnFailedPublish)
            throw this.removeRequestFromQueue(p4), c2;
          return;
        } finally {
          clearTimeout(M4);
        }
        this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i3, message: s, opts: n2 } });
      } catch (o2) {
        throw this.logger.debug("Failed to Publish Payload"), this.logger.error(o2), o2;
      }
    }, this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.relayer = e2, this.logger = (0, import_logger2.generateChildLogger)(t, this.name), this.registerEventListeners();
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  rpcPublish(e2, t, i3, s, n2, a2, o2) {
    var h3, u3, d4, p4;
    const y4 = { method: yt2(s.protocol).publish, params: { topic: e2, message: t, ttl: i3, prompt: n2, tag: a2 }, id: o2 };
    return w((h3 = y4.params) == null ? void 0 : h3.prompt) && ((u3 = y4.params) == null || delete u3.prompt), w((d4 = y4.params) == null ? void 0 : d4.tag) && ((p4 = y4.params) == null || delete p4.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: y4 }), this.relayer.request(y4);
  }
  removeRequestFromQueue(e2) {
    this.queue.delete(e2);
  }
  checkQueue() {
    this.queue.forEach(async (e2) => {
      const { topic: t, message: i3, opts: s } = e2;
      await this.publish(t, i3, s);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(D3.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(D3.message_ack, (e2) => {
      this.removeRequestFromQueue(e2.id.toString());
    });
  }
};
var mr2 = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e2, t) => {
      const i3 = this.get(e2);
      this.exists(e2, t) || this.map.set(e2, [...i3, t]);
    }, this.get = (e2) => this.map.get(e2) || [], this.exists = (e2, t) => this.get(e2).includes(t), this.delete = (e2, t) => {
      if (typeof t > "u") {
        this.map.delete(e2);
        return;
      }
      if (!this.map.has(e2))
        return;
      const i3 = this.get(e2);
      if (!this.exists(e2, t))
        return;
      const s = i3.filter((n2) => n2 !== t);
      if (!s.length) {
        this.map.delete(e2);
        return;
      }
      this.map.set(e2, s);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var br2 = Object.defineProperty;
var fr2 = Object.defineProperties;
var Er2 = Object.getOwnPropertyDescriptors;
var Pt2 = Object.getOwnPropertySymbols;
var wr2 = Object.prototype.hasOwnProperty;
var vr2 = Object.prototype.propertyIsEnumerable;
var xt3 = (r, e2, t) => e2 in r ? br2(r, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r[e2] = t;
var q3 = (r, e2) => {
  for (var t in e2 || (e2 = {}))
    wr2.call(e2, t) && xt3(r, t, e2[t]);
  if (Pt2)
    for (var t of Pt2(e2))
      vr2.call(e2, t) && xt3(r, t, e2[t]);
  return r;
};
var De3 = (r, e2) => fr2(r, Er2(e2));
var Ot2 = class extends d2 {
  constructor(e2, t) {
    super(e2, t), this.relayer = e2, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new mr2(), this.events = new import_events4.EventEmitter(), this.name = yt3, this.version = mt3, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = O3, this.subscribeTimeout = 1e4, this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (i3, s) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s } });
      try {
        const n2 = mt2(s), a2 = { topic: i3, relay: n2 };
        this.pending.set(i3, a2);
        const o2 = await this.rpcSubscribe(i3, n2);
        return this.onSubscribe(o2, a2), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s } }), o2;
      } catch (n2) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n2), n2;
      }
    }, this.unsubscribe = async (i3, s) => {
      await this.restartToComplete(), this.isInitialized(), typeof (s == null ? void 0 : s.id) < "u" ? await this.unsubscribeById(i3, s.id, s) : await this.unsubscribeByTopic(i3, s);
    }, this.isSubscribed = async (i3) => this.topics.includes(i3) ? true : await new Promise((s, n2) => {
      const a2 = new import_time3.Watch();
      a2.start(this.pendingSubscriptionWatchLabel);
      const o2 = setInterval(() => {
        !this.pending.has(i3) && this.topics.includes(i3) && (clearInterval(o2), a2.stop(this.pendingSubscriptionWatchLabel), s(true)), a2.elapsed(this.pendingSubscriptionWatchLabel) >= bt3 && (clearInterval(o2), a2.stop(this.pendingSubscriptionWatchLabel), n2(new Error("Subscription resolution timeout")));
      }, this.pollingInterval);
    }).catch(() => false), this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.restart = async () => {
      this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
    }, this.relayer = e2, this.logger = (0, import_logger2.generateChildLogger)(t, this.name), this.clientId = "";
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e2, t) {
    let i3 = false;
    try {
      i3 = this.getSubscription(e2).topic === t;
    } catch {
    }
    return i3;
  }
  onEnable() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e2, t) {
    const i3 = this.topicMap.get(e2);
    await Promise.all(i3.map(async (s) => await this.unsubscribeById(e2, s, t)));
  }
  async unsubscribeById(e2, t, i3) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e2, id: t, opts: i3 } });
    try {
      const s = mt2(i3);
      await this.rpcUnsubscribe(e2, t, s);
      const n2 = U2("USER_DISCONNECTED", `${this.name}, ${e2}`);
      await this.onUnsubscribe(e2, t, n2), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e2, id: t, opts: i3 } });
    } catch (s) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s), s;
    }
  }
  async rpcSubscribe(e2, t) {
    const i3 = { method: yt2(t.protocol).subscribe, params: { topic: e2 } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      await await it2(this.relayer.request(i3), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(D3.connection_stalled);
    }
    return Mn(e2 + this.clientId);
  }
  async rpcBatchSubscribe(e2) {
    if (!e2.length)
      return;
    const t = e2[0].relay, i3 = { method: yt2(t.protocol).batchSubscribe, params: { topics: e2.map((s) => s.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      return await await it2(this.relayer.request(i3), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(D3.connection_stalled);
    }
  }
  rpcUnsubscribe(e2, t, i3) {
    const s = { method: yt2(i3.protocol).unsubscribe, params: { topic: e2, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s }), this.relayer.request(s);
  }
  onSubscribe(e2, t) {
    this.setSubscription(e2, De3(q3({}, t), { id: e2 })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e2) {
    e2.length && e2.forEach((t) => {
      this.setSubscription(t.id, q3({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e2, t, i3) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e2) && this.deleteSubscription(t, i3), await this.relayer.messages.del(e2);
  }
  async setRelayerSubscriptions(e2) {
    await this.relayer.core.storage.setItem(this.storageKey, e2);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e2, t) {
    this.subscriptions.has(e2) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e2, subscription: t }), this.addSubscription(e2, t));
  }
  addSubscription(e2, t) {
    this.subscriptions.set(e2, q3({}, t)), this.topicMap.set(t.topic, e2), this.events.emit(w2.created, t);
  }
  getSubscription(e2) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e2 });
    const t = this.subscriptions.get(e2);
    if (!t) {
      const { message: i3 } = N3("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw new Error(i3);
    }
    return t;
  }
  deleteSubscription(e2, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e2, reason: t });
    const i3 = this.getSubscription(e2);
    this.subscriptions.delete(e2), this.topicMap.delete(i3.topic, e2), this.events.emit(w2.deleted, De3(q3({}, i3), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(w2.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e2 = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let t = 0; t < e2; t++) {
        const i3 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i3);
      }
    }
    this.events.emit(w2.resubscribed);
  }
  async restore() {
    try {
      const e2 = await this.getRelayerSubscriptions();
      if (typeof e2 > "u" || !e2.length)
        return;
      if (this.subscriptions.size) {
        const { message: t } = N3("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e2);
    }
  }
  async batchSubscribe(e2) {
    if (!e2.length)
      return;
    const t = await this.rpcBatchSubscribe(e2);
    D2(t) && this.onBatchSubscribe(t.map((i3, s) => De3(q3({}, e2[s]), { id: i3 })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || this.relayer.transportExplicitlyClosed)
      return;
    const e2 = [];
    this.pending.forEach((t) => {
      e2.push(t);
    }), await this.batchSubscribe(e2);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.relayer.on(D3.connect, async () => {
      await this.onConnect();
    }), this.relayer.on(D3.disconnect, () => {
      this.onDisconnect();
    }), this.events.on(w2.created, async (e2) => {
      const t = w2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), await this.persist();
    }), this.events.on(w2.deleted, async (e2) => {
      const t = w2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N3("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((e2) => {
      const t = setInterval(() => {
        this.restartInProgress || (clearInterval(t), e2());
      }, this.pollingInterval);
    });
  }
};
var Ir = Object.defineProperty;
var At3 = Object.getOwnPropertySymbols;
var Cr2 = Object.prototype.hasOwnProperty;
var Rr2 = Object.prototype.propertyIsEnumerable;
var zt3 = (r, e2, t) => e2 in r ? Ir(r, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r[e2] = t;
var _r2 = (r, e2) => {
  for (var t in e2 || (e2 = {}))
    Cr2.call(e2, t) && zt3(r, t, e2[t]);
  if (At3)
    for (var t of At3(e2))
      Rr2.call(e2, t) && zt3(r, t, e2[t]);
  return r;
};
var Nt3 = class extends g {
  constructor(e2) {
    super(e2), this.protocol = "wc", this.version = 2, this.events = new import_events4.EventEmitter(), this.name = ct3, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.hasExperiencedNetworkDisruption = false, this.request = async (t) => {
      this.logger.debug("Publishing Request Payload");
      try {
        return await this.toEstablishConnection(), await this.provider.request(t);
      } catch (i3) {
        throw this.logger.debug("Failed to Publish Request"), this.logger.error(i3), i3;
      }
    }, this.onPayloadHandler = (t) => {
      this.onProviderPayload(t);
    }, this.onConnectHandler = () => {
      this.events.emit(D3.connect);
    }, this.onDisconnectHandler = () => {
      this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (t) => {
      this.logger.error(t), this.events.emit(D3.error, t), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(P.payload, this.onPayloadHandler), this.provider.on(P.connect, this.onConnectHandler), this.provider.on(P.disconnect, this.onDisconnectHandler), this.provider.on(P.error, this.onProviderErrorHandler);
    }, this.core = e2.core, this.logger = typeof e2.logger < "u" && typeof e2.logger != "string" ? (0, import_logger2.generateChildLogger)(e2.logger, this.name) : (0, import_logger2.pino)((0, import_logger2.getDefaultLoggerOptions)({ level: e2.logger || ht3 })), this.messages = new Tt2(this.logger, e2.core), this.subscriber = new Ot2(this, this.logger), this.publisher = new yr2(this, this.logger), this.relayUrl = (e2 == null ? void 0 : e2.relayUrl) || ge2, this.projectId = e2.projectId, this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
    try {
      await this.transportOpen();
    } catch {
      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${pe2}...`), await this.restartTransport(pe2);
    }
    this.initialized = true, setTimeout(async () => {
      this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = false);
    }, gt3);
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(e2, t, i3) {
    this.isInitialized(), await this.publisher.publish(e2, t, i3), await this.recordMessageEvent({ topic: e2, message: t, publishedAt: Date.now() });
  }
  async subscribe(e2, t) {
    var i3;
    this.isInitialized();
    let s = ((i3 = this.subscriber.topicMap.get(e2)) == null ? void 0 : i3[0]) || "";
    if (s)
      return s;
    let n2;
    const a2 = (o2) => {
      o2.topic === e2 && (this.subscriber.off(w2.created, a2), n2());
    };
    return await Promise.all([new Promise((o2) => {
      n2 = o2, this.subscriber.on(w2.created, a2);
    }), new Promise(async (o2) => {
      s = await this.subscriber.subscribe(e2, t), o2();
    })]), s;
  }
  async unsubscribe(e2, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e2, t);
  }
  on(e2, t) {
    this.events.on(e2, t);
  }
  once(e2, t) {
    this.events.once(e2, t);
  }
  off(e2, t) {
    this.events.off(e2, t);
  }
  removeListener(e2, t) {
    this.events.removeListener(e2, t);
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, this.hasExperiencedNetworkDisruption && this.connected ? await it2(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect();
  }
  async transportOpen(e2) {
    if (this.transportExplicitlyClosed = false, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {
      e2 && e2 !== this.relayUrl && (this.relayUrl = e2, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = true;
      try {
        await Promise.all([new Promise((t) => {
          if (!this.initialized)
            return t();
          this.subscriber.once(w2.resubscribed, () => {
            t();
          });
        }), new Promise(async (t, i3) => {
          try {
            await it2(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`);
          } catch (s) {
            i3(s);
            return;
          }
          t();
        })]);
      } catch (t) {
        this.logger.error(t);
        const i3 = t;
        if (!this.isConnectionStalled(i3.message))
          throw t;
        this.provider.events.emit(P.disconnect);
      } finally {
        this.connectionAttemptInProgress = false, this.hasExperiencedNetworkDisruption = false;
      }
    }
  }
  async restartTransport(e2) {
    await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress && (this.relayUrl = e2 || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Zt2())
      throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  isConnectionStalled(e2) {
    return this.staleConnectionErrors.some((t) => e2.includes(t));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e2 = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new JsonRpcProvider(new esm_default(Jn({ sdkVersion: dt3, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e2, useOnCloseEvent: true }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e2) {
    const { topic: t, message: i3 } = e2;
    await this.messages.set(t, i3);
  }
  async shouldIgnoreMessageEvent(e2) {
    const { topic: t, message: i3 } = e2;
    if (!i3 || i3.length === 0)
      return this.logger.debug(`Ignoring invalid/empty message: ${i3}`), true;
    if (!await this.subscriber.isSubscribed(t))
      return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`), true;
    const s = this.messages.has(t, i3);
    return s && this.logger.debug(`Ignoring duplicate message: ${i3}`), s;
  }
  async onProviderPayload(e2) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e2 }), isJsonRpcRequest(e2)) {
      if (!e2.method.endsWith(ut3))
        return;
      const t = e2.params, { topic: i3, message: s, publishedAt: n2 } = t.data, a2 = { topic: i3, message: s, publishedAt: n2 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(_r2({ type: "event", event: t.id }, a2)), this.events.emit(t.id, a2), await this.acknowledgePayload(e2), await this.onMessageEvent(a2);
    } else
      isJsonRpcResponse(e2) && this.events.emit(D3.message_ack, e2);
  }
  async onMessageEvent(e2) {
    await this.shouldIgnoreMessageEvent(e2) || (this.events.emit(D3.message, e2), await this.recordMessageEvent(e2));
  }
  async acknowledgePayload(e2) {
    const t = formatJsonRpcResult(e2.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(P.payload, this.onPayloadHandler), this.provider.off(P.connect, this.onConnectHandler), this.provider.off(P.disconnect, this.onDisconnectHandler), this.provider.off(P.error, this.onProviderErrorHandler);
  }
  async registerEventListeners() {
    this.events.on(D3.connection_stalled, () => {
      this.restartTransport().catch((t) => this.logger.error(t));
    });
    let e2 = await Zt2();
    Xt2(async (t) => {
      this.initialized && e2 !== t && (e2 = t, t ? await this.restartTransport().catch((i3) => this.logger.error(i3)) : (this.hasExperiencedNetworkDisruption = true, await this.transportClose().catch((i3) => this.logger.error(i3))));
    });
  }
  onProviderDisconnect() {
    this.events.emit(D3.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."), setTimeout(async () => {
      await this.restartTransport().catch((e2) => this.logger.error(e2));
    }, (0, import_time3.toMiliseconds)(lt3)));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N3("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectionAttemptInProgress)
        return await new Promise((e2) => {
          const t = setInterval(() => {
            this.connected && (clearInterval(t), e2());
          }, this.connectionStatusPollingInterval);
        });
      await this.restartTransport();
    }
  }
};
var Sr2 = Object.defineProperty;
var Ut2 = Object.getOwnPropertySymbols;
var Tr2 = Object.prototype.hasOwnProperty;
var Pr2 = Object.prototype.propertyIsEnumerable;
var Lt3 = (r, e2, t) => e2 in r ? Sr2(r, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r[e2] = t;
var Ft3 = (r, e2) => {
  for (var t in e2 || (e2 = {}))
    Tr2.call(e2, t) && Lt3(r, t, e2[t]);
  if (Ut2)
    for (var t of Ut2(e2))
      Pr2.call(e2, t) && Lt3(r, t, e2[t]);
  return r;
};
var $t4 = class extends p {
  constructor(e2, t, i3, s = O3, n2 = void 0) {
    super(e2, t, i3, s), this.core = e2, this.logger = t, this.name = i3, this.map = /* @__PURE__ */ new Map(), this.version = pt3, this.cached = [], this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((a2) => {
        this.getKey && a2 !== null && !w(a2) ? this.map.set(this.getKey(a2), a2) : Dt2(a2) ? this.map.set(a2.id, a2) : kt2(a2) && this.map.set(a2.topic, a2);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (a2, o2) => {
      this.isInitialized(), this.map.has(a2) ? await this.update(a2, o2) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: a2, value: o2 }), this.map.set(a2, o2), await this.persist());
    }, this.get = (a2) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: a2 }), this.getData(a2)), this.getAll = (a2) => (this.isInitialized(), a2 ? this.values.filter((o2) => Object.keys(a2).every((h3) => (0, import_lodash.default)(o2[h3], a2[h3]))) : this.values), this.update = async (a2, o2) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: a2, update: o2 });
      const h3 = Ft3(Ft3({}, this.getData(a2)), o2);
      this.map.set(a2, h3), await this.persist();
    }, this.delete = async (a2, o2) => {
      this.isInitialized(), this.map.has(a2) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: a2, reason: o2 }), this.map.delete(a2), await this.persist());
    }, this.logger = (0, import_logger2.generateChildLogger)(t, this.name), this.storagePrefix = s, this.getKey = n2;
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e2) {
    const t = this.map.get(e2);
    if (!t) {
      const { message: i3 } = N3("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw this.logger.error(i3), new Error(i3);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e2 = await this.getDataStore();
      if (typeof e2 > "u" || !e2.length)
        return;
      if (this.map.size) {
        const { message: t } = N3("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N3("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var Mt3 = class {
  constructor(e2, t) {
    this.core = e2, this.logger = t, this.name = ft3, this.version = Et3, this.events = new import_events4.default(), this.initialized = false, this.storagePrefix = O3, this.ignoredPayloadTypes = [_2], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: i3 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i3])];
    }, this.create = async () => {
      this.isInitialized();
      const i3 = Dn(), s = await this.core.crypto.setSymKey(i3), n2 = lt2(import_time3.FIVE_MINUTES), a2 = { protocol: ot2 }, o2 = { topic: s, expiry: n2, relay: a2, active: false }, h3 = Nt2({ protocol: this.core.protocol, version: this.core.version, topic: s, symKey: i3, relay: a2 });
      return await this.pairings.set(s, o2), await this.core.relayer.subscribe(s), this.core.expirer.set(s, n2), { topic: s, uri: h3 };
    }, this.pair = async (i3) => {
      this.isInitialized(), this.isValidPair(i3);
      const { topic: s, symKey: n2, relay: a2 } = bt2(i3.uri);
      let o2;
      if (this.pairings.keys.includes(s) && (o2 = this.pairings.get(s), o2.active))
        throw new Error(`Pairing already exists: ${s}. Please try again with a new connection URI.`);
      this.core.crypto.keychain.has(s) || (await this.core.crypto.setSymKey(n2, s), await this.core.relayer.subscribe(s, { relay: a2 }));
      const h3 = lt2(import_time3.FIVE_MINUTES), u3 = { topic: s, relay: a2, expiry: h3, active: false };
      return await this.pairings.set(s, u3), this.core.expirer.set(s, h3), i3.activatePairing && await this.activate({ topic: s }), this.events.emit(V4.create, u3), u3;
    }, this.activate = async ({ topic: i3 }) => {
      this.isInitialized();
      const s = lt2(import_time3.THIRTY_DAYS);
      await this.pairings.update(i3, { active: true, expiry: s }), this.core.expirer.set(i3, s);
    }, this.ping = async (i3) => {
      this.isInitialized(), await this.isValidPing(i3);
      const { topic: s } = i3;
      if (this.pairings.keys.includes(s)) {
        const n2 = await this.sendRequest(s, "wc_pairingPing", {}), { done: a2, resolve: o2, reject: h3 } = st2();
        this.events.once(ft2("pairing_ping", n2), ({ error: u3 }) => {
          u3 ? h3(u3) : o2();
        }), await a2();
      }
    }, this.updateExpiry = async ({ topic: i3, expiry: s }) => {
      this.isInitialized(), await this.pairings.update(i3, { expiry: s });
    }, this.updateMetadata = async ({ topic: i3, metadata: s }) => {
      this.isInitialized(), await this.pairings.update(i3, { peerMetadata: s });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (i3) => {
      this.isInitialized(), await this.isValidDisconnect(i3);
      const { topic: s } = i3;
      this.pairings.keys.includes(s) && (await this.sendRequest(s, "wc_pairingDelete", U2("USER_DISCONNECTED")), await this.deletePairing(s));
    }, this.sendRequest = async (i3, s, n2) => {
      const a2 = formatJsonRpcRequest(s, n2), o2 = await this.core.crypto.encode(i3, a2), h3 = F3[s].req;
      return this.core.history.set(i3, a2), this.core.relayer.publish(i3, o2, h3), a2.id;
    }, this.sendResult = async (i3, s, n2) => {
      const a2 = formatJsonRpcResult(i3, n2), o2 = await this.core.crypto.encode(s, a2), h3 = await this.core.history.get(s, i3), u3 = F3[h3.request.method].res;
      await this.core.relayer.publish(s, o2, u3), await this.core.history.resolve(a2);
    }, this.sendError = async (i3, s, n2) => {
      const a2 = formatJsonRpcError(i3, n2), o2 = await this.core.crypto.encode(s, a2), h3 = await this.core.history.get(s, i3), u3 = F3[h3.request.method] ? F3[h3.request.method].res : F3.unregistered_method.res;
      await this.core.relayer.publish(s, o2, u3), await this.core.history.resolve(a2);
    }, this.deletePairing = async (i3, s) => {
      await this.core.relayer.unsubscribe(i3), await Promise.all([this.pairings.delete(i3, U2("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i3), s ? Promise.resolve() : this.core.expirer.del(i3)]);
    }, this.cleanup = async () => {
      const i3 = this.pairings.getAll().filter((s) => dt2(s.expiry));
      await Promise.all(i3.map((s) => this.deletePairing(s.topic)));
    }, this.onRelayEventRequest = (i3) => {
      const { topic: s, payload: n2 } = i3;
      switch (n2.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(s, n2);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(s, n2);
        default:
          return this.onUnknownRpcMethodRequest(s, n2);
      }
    }, this.onRelayEventResponse = async (i3) => {
      const { topic: s, payload: n2 } = i3, a2 = (await this.core.history.get(s, n2.id)).request.method;
      switch (a2) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s, n2);
        default:
          return this.onUnknownRpcMethodResponse(a2);
      }
    }, this.onPairingPingRequest = async (i3, s) => {
      const { id: n2 } = s;
      try {
        this.isValidPing({ topic: i3 }), await this.sendResult(n2, i3, true), this.events.emit(V4.ping, { id: n2, topic: i3 });
      } catch (a2) {
        await this.sendError(n2, i3, a2), this.logger.error(a2);
      }
    }, this.onPairingPingResponse = (i3, s) => {
      const { id: n2 } = s;
      setTimeout(() => {
        isJsonRpcResult(s) ? this.events.emit(ft2("pairing_ping", n2), {}) : isJsonRpcError(s) && this.events.emit(ft2("pairing_ping", n2), { error: s.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (i3, s) => {
      const { id: n2 } = s;
      try {
        this.isValidDisconnect({ topic: i3 }), await this.deletePairing(i3), this.events.emit(V4.delete, { id: n2, topic: i3 });
      } catch (a2) {
        await this.sendError(n2, i3, a2), this.logger.error(a2);
      }
    }, this.onUnknownRpcMethodRequest = async (i3, s) => {
      const { id: n2, method: a2 } = s;
      try {
        if (this.registeredMethods.includes(a2))
          return;
        const o2 = U2("WC_METHOD_UNSUPPORTED", a2);
        await this.sendError(n2, i3, o2), this.logger.error(o2);
      } catch (o2) {
        await this.sendError(n2, i3, o2), this.logger.error(o2);
      }
    }, this.onUnknownRpcMethodResponse = (i3) => {
      this.registeredMethods.includes(i3) || this.logger.error(U2("WC_METHOD_UNSUPPORTED", i3));
    }, this.isValidPair = (i3) => {
      if (!xt2(i3)) {
        const { message: s } = N3("MISSING_OR_INVALID", `pair() params: ${i3}`);
        throw new Error(s);
      }
      if (!jt3(i3.uri)) {
        const { message: s } = N3("MISSING_OR_INVALID", `pair() uri: ${i3.uri}`);
        throw new Error(s);
      }
    }, this.isValidPing = async (i3) => {
      if (!xt2(i3)) {
        const { message: n2 } = N3("MISSING_OR_INVALID", `ping() params: ${i3}`);
        throw new Error(n2);
      }
      const { topic: s } = i3;
      await this.isValidPairingTopic(s);
    }, this.isValidDisconnect = async (i3) => {
      if (!xt2(i3)) {
        const { message: n2 } = N3("MISSING_OR_INVALID", `disconnect() params: ${i3}`);
        throw new Error(n2);
      }
      const { topic: s } = i3;
      await this.isValidPairingTopic(s);
    }, this.isValidPairingTopic = async (i3) => {
      if (!h2(i3, false)) {
        const { message: s } = N3("MISSING_OR_INVALID", `pairing topic should be a string: ${i3}`);
        throw new Error(s);
      }
      if (!this.pairings.keys.includes(i3)) {
        const { message: s } = N3("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i3}`);
        throw new Error(s);
      }
      if (dt2(this.pairings.get(i3).expiry)) {
        await this.deletePairing(i3);
        const { message: s } = N3("EXPIRED", `pairing topic: ${i3}`);
        throw new Error(s);
      }
    }, this.core = e2, this.logger = (0, import_logger2.generateChildLogger)(t, this.name), this.pairings = new $t4(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N3("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(D3.message, async (e2) => {
      const { topic: t, message: i3 } = e2;
      if (!this.pairings.keys.includes(t) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i3)))
        return;
      const s = await this.core.crypto.decode(t, i3);
      try {
        isJsonRpcRequest(s) ? (this.core.history.set(t, s), this.onRelayEventRequest({ topic: t, payload: s })) : isJsonRpcResponse(s) && (await this.core.history.resolve(s), await this.onRelayEventResponse({ topic: t, payload: s }), this.core.history.delete(t, s.id));
      } catch (n2) {
        this.logger.error(n2);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(v.expired, async (e2) => {
      const { topic: t } = ut2(e2.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(V4.expire, { topic: t }));
    });
  }
};
var kt3 = class extends h {
  constructor(e2, t) {
    super(e2, t), this.core = e2, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new import_events4.EventEmitter(), this.name = wt2, this.version = vt3, this.cached = [], this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.records.set(i3.id, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (i3, s, n2) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i3, request: s, chainId: n2 }), this.records.has(s.id))
        return;
      const a2 = { id: s.id, topic: i3, request: { method: s.method, params: s.params || null }, chainId: n2, expiry: lt2(import_time3.THIRTY_DAYS) };
      this.records.set(a2.id, a2), this.events.emit(R3.created, a2);
    }, this.resolve = async (i3) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i3 }), !this.records.has(i3.id))
        return;
      const s = await this.getRecord(i3.id);
      typeof s.response > "u" && (s.response = isJsonRpcError(i3) ? { error: i3.error } : { result: i3.result }, this.records.set(s.id, s), this.events.emit(R3.updated, s));
    }, this.get = async (i3, s) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i3, id: s }), await this.getRecord(s)), this.delete = (i3, s) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s }), this.values.forEach((n2) => {
        if (n2.topic === i3) {
          if (typeof s < "u" && n2.id !== s)
            return;
          this.records.delete(n2.id), this.events.emit(R3.deleted, n2);
        }
      });
    }, this.exists = async (i3, s) => (this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === i3 : false), this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.logger = (0, import_logger2.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e2 = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u")
        return;
      const i3 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e2.push(i3);
    }), e2;
  }
  async setJsonRpcRecords(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e2) {
    this.isInitialized();
    const t = this.records.get(e2);
    if (!t) {
      const { message: i3 } = N3("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw new Error(i3);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(R3.sync);
  }
  async restore() {
    try {
      const e2 = await this.getJsonRpcRecords();
      if (typeof e2 > "u" || !e2.length)
        return;
      if (this.records.size) {
        const { message: t } = N3("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e2);
    }
  }
  registerEventListeners() {
    this.events.on(R3.created, (e2) => {
      const t = R3.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e2 }), this.persist();
    }), this.events.on(R3.updated, (e2) => {
      const t = R3.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e2 }), this.persist();
    }), this.events.on(R3.deleted, (e2) => {
      const t = R3.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e2 }), this.persist();
    }), this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.records.forEach((e2) => {
        (0, import_time3.toMiliseconds)(e2.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e2.id}`), this.delete(e2.topic, e2.id));
      });
    } catch (e2) {
      this.logger.warn(e2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N3("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var Kt3 = class extends E {
  constructor(e2, t) {
    super(e2, t), this.core = e2, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events4.EventEmitter(), this.name = It2, this.version = Ct3, this.cached = [], this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.expirations.set(i3.target, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (i3) => {
      try {
        const s = this.formatTarget(i3);
        return typeof this.getExpiration(s) < "u";
      } catch {
        return false;
      }
    }, this.set = (i3, s) => {
      this.isInitialized();
      const n2 = this.formatTarget(i3), a2 = { target: n2, expiry: s };
      this.expirations.set(n2, a2), this.checkExpiry(n2, a2), this.events.emit(v.created, { target: n2, expiration: a2 });
    }, this.get = (i3) => {
      this.isInitialized();
      const s = this.formatTarget(i3);
      return this.getExpiration(s);
    }, this.del = (i3) => {
      if (this.isInitialized(), this.has(i3)) {
        const s = this.formatTarget(i3), n2 = this.getExpiration(s);
        this.expirations.delete(s), this.events.emit(v.deleted, { target: s, expiration: n2 });
      }
    }, this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.logger = (0, import_logger2.generateChildLogger)(t, this.name);
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e2) {
    if (typeof e2 == "string")
      return ct2(e2);
    if (typeof e2 == "number")
      return at2(e2);
    const { message: t } = N3("UNKNOWN_TYPE", `Target type: ${typeof e2}`);
    throw new Error(t);
  }
  async setExpirations(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(v.sync);
  }
  async restore() {
    try {
      const e2 = await this.getExpirations();
      if (typeof e2 > "u" || !e2.length)
        return;
      if (this.expirations.size) {
        const { message: t } = N3("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e2);
    }
  }
  getExpiration(e2) {
    const t = this.expirations.get(e2);
    if (!t) {
      const { message: i3 } = N3("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw this.logger.error(i3), new Error(i3);
    }
    return t;
  }
  checkExpiry(e2, t) {
    const { expiry: i3 } = t;
    (0, import_time3.toMiliseconds)(i3) - Date.now() <= 0 && this.expire(e2, t);
  }
  expire(e2, t) {
    this.expirations.delete(e2), this.events.emit(v.expired, { target: e2, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e2, t) => this.checkExpiry(t, e2));
  }
  registerEventListeners() {
    this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(v.created, (e2) => {
      const t = v.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), this.persist();
    }), this.events.on(v.expired, (e2) => {
      const t = v.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), this.persist();
    }), this.events.on(v.deleted, (e2) => {
      const t = v.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N3("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var Bt3 = class extends y {
  constructor(e2, t) {
    super(e2, t), this.projectId = e2, this.logger = t, this.name = Z3, this.initialized = false, this.queue = [], this.verifyDisabled = false, this.init = async (i3) => {
      if (this.verifyDisabled || j2() || !q2())
        return;
      const s = this.getVerifyUrl(i3 == null ? void 0 : i3.verifyUrl);
      this.verifyUrl !== s && this.removeIframe(), this.verifyUrl = s;
      try {
        await this.createIframe();
      } catch (n2) {
        this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(n2);
      }
      if (!this.initialized) {
        this.removeIframe(), this.verifyUrl = ee3;
        try {
          await this.createIframe();
        } catch (n2) {
          this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(n2), this.verifyDisabled = true;
        }
      }
    }, this.register = async (i3) => {
      this.initialized ? this.sendPost(i3.attestationId) : (this.addToQueue(i3.attestationId), await this.init());
    }, this.resolve = async (i3) => {
      if (this.isDevEnv)
        return "";
      const s = this.getVerifyUrl(i3 == null ? void 0 : i3.verifyUrl);
      let n2;
      try {
        n2 = await this.fetchAttestation(i3.attestationId, s);
      } catch (a2) {
        this.logger.info(`failed to resolve attestation: ${i3.attestationId} from url: ${s}`), this.logger.info(a2), n2 = await this.fetchAttestation(i3.attestationId, ee3);
      }
      return n2;
    }, this.fetchAttestation = async (i3, s) => {
      this.logger.info(`resolving attestation: ${i3} from url: ${s}`);
      const n2 = this.startAbortTimer(import_time3.ONE_SECOND * 2), a2 = await fetch(`${s}/attestation/${i3}`, { signal: this.abortController.signal });
      return clearTimeout(n2), a2.status === 200 ? await a2.json() : void 0;
    }, this.addToQueue = (i3) => {
      this.queue.push(i3);
    }, this.processQueue = () => {
      this.queue.length !== 0 && (this.queue.forEach((i3) => this.sendPost(i3)), this.queue = []);
    }, this.sendPost = (i3) => {
      var s;
      try {
        if (!this.iframe)
          return;
        (s = this.iframe.contentWindow) == null || s.postMessage(i3, "*"), this.logger.info(`postMessage sent: ${i3} ${this.verifyUrl}`);
      } catch {
      }
    }, this.createIframe = async () => {
      let i3;
      const s = (n2) => {
        n2.data === "verify_ready" && (this.initialized = true, this.processQueue(), window.removeEventListener("message", s), i3());
      };
      await Promise.race([new Promise((n2) => {
        if (document.getElementById(Z3))
          return n2();
        window.addEventListener("message", s);
        const a2 = document.createElement("iframe");
        a2.id = Z3, a2.src = `${this.verifyUrl}/${this.projectId}`, a2.style.display = "none", document.body.append(a2), this.iframe = a2, i3 = n2;
      }), new Promise((n2, a2) => setTimeout(() => {
        window.removeEventListener("message", s), a2("verify iframe load timeout");
      }, (0, import_time3.toMiliseconds)(import_time3.FIVE_SECONDS)))]);
    }, this.removeIframe = () => {
      this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = false);
    }, this.getVerifyUrl = (i3) => {
      let s = i3 || $3;
      return Rt2.includes(s) || (this.logger.info(`verify url: ${s}, not included in trusted list, assigning default: ${$3}`), s = $3), s;
    }, this.logger = (0, import_logger2.generateChildLogger)(t, this.name), this.verifyUrl = $3, this.abortController = new AbortController(), this.isDevEnv = te2() && import_process.default.env.IS_VITEST;
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  startAbortTimer(e2) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time3.toMiliseconds)(e2));
  }
};
var xr2 = Object.defineProperty;
var Vt3 = Object.getOwnPropertySymbols;
var Or2 = Object.prototype.hasOwnProperty;
var Ar2 = Object.prototype.propertyIsEnumerable;
var qt3 = (r, e2, t) => e2 in r ? xr2(r, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r[e2] = t;
var jt4 = (r, e2) => {
  for (var t in e2 || (e2 = {}))
    Or2.call(e2, t) && qt3(r, t, e2[t]);
  if (Vt3)
    for (var t of Vt3(e2))
      Ar2.call(e2, t) && qt3(r, t, e2[t]);
  return r;
};
var te3 = class extends n {
  constructor(e2) {
    super(e2), this.protocol = le3, this.version = We3, this.name = Q3, this.events = new import_events4.EventEmitter(), this.initialized = false, this.on = (i3, s) => this.events.on(i3, s), this.once = (i3, s) => this.events.once(i3, s), this.off = (i3, s) => this.events.off(i3, s), this.removeListener = (i3, s) => this.events.removeListener(i3, s), this.projectId = e2 == null ? void 0 : e2.projectId, this.relayUrl = (e2 == null ? void 0 : e2.relayUrl) || ge2, this.customStoragePrefix = e2 != null && e2.customStoragePrefix ? `:${e2.customStoragePrefix}` : "";
    const t = typeof (e2 == null ? void 0 : e2.logger) < "u" && typeof (e2 == null ? void 0 : e2.logger) != "string" ? e2.logger : (0, import_logger2.pino)((0, import_logger2.getDefaultLoggerOptions)({ level: (e2 == null ? void 0 : e2.logger) || Xe2.logger }));
    this.logger = (0, import_logger2.generateChildLogger)(t, this.name), this.heartbeat = new import_heartbeat.HeartBeat(), this.crypto = new St2(this, this.logger, e2 == null ? void 0 : e2.keychain), this.history = new kt3(this, this.logger), this.expirer = new Kt3(this, this.logger), this.storage = e2 != null && e2.storage ? e2.storage : new import_keyvaluestorage.default(jt4(jt4({}, Qe2), e2 == null ? void 0 : e2.storageOptions)), this.relayer = new Nt3({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Mt3(this, this.logger), this.verify = new Bt3(this.projectId || "", this.logger);
  }
  static async init(e2) {
    const t = new te3(e2);
    await t.initialize();
    const i3 = await t.crypto.getClientId();
    return await t.storage.setItem(Dt3, i3), t;
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e2) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e2), this.logger.error(e2.message), e2;
    }
  }
};
var zr3 = te3;

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_logger3 = __toESM(require_cjs3());
var import_events5 = __toESM(require_events());
var import_time4 = __toESM(require_cjs());
var X3 = "wc";
var F4 = 2;
var H2 = "client";
var G3 = `${X3}@${F4}:${H2}:`;
var M2 = { name: H2, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.com" };
var W4 = "WALLETCONNECT_DEEPLINK_CHOICE";
var ne2 = "proposal";
var oe2 = "Proposal expired";
var ae3 = "session";
var A2 = import_time4.SEVEN_DAYS;
var ce4 = "engine";
var V5 = { wc_sessionPropose: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1101 } }, wc_sessionSettle: { req: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time4.THIRTY_SECONDS, prompt: false, tag: 1114 }, res: { ttl: import_time4.THIRTY_SECONDS, prompt: false, tag: 1115 } } };
var U4 = { min: import_time4.FIVE_MINUTES, max: import_time4.SEVEN_DAYS };
var I2 = { idle: "IDLE", active: "ACTIVE" };
var le4 = "request";
var pe3 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var ns2 = Object.defineProperty;
var os2 = Object.defineProperties;
var as2 = Object.getOwnPropertyDescriptors;
var he4 = Object.getOwnPropertySymbols;
var cs2 = Object.prototype.hasOwnProperty;
var ls2 = Object.prototype.propertyIsEnumerable;
var de4 = (m3, r, e2) => r in m3 ? ns2(m3, r, { enumerable: true, configurable: true, writable: true, value: e2 }) : m3[r] = e2;
var g3 = (m3, r) => {
  for (var e2 in r || (r = {}))
    cs2.call(r, e2) && de4(m3, e2, r[e2]);
  if (he4)
    for (var e2 of he4(r))
      ls2.call(r, e2) && de4(m3, e2, r[e2]);
  return m3;
};
var b2 = (m3, r) => os2(m3, as2(r));
var ps2 = class extends S2 {
  constructor(r) {
    super(r), this.name = ce4, this.events = new import_events5.default(), this.initialized = false, this.ignoredPayloadTypes = [_2], this.requestQueue = { state: I2.idle, queue: [] }, this.sessionRequestQueue = { state: I2.idle, queue: [] }, this.requestQueueDelay = import_time4.ONE_SECOND, this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(V5) }), this.initialized = true, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time4.toMiliseconds)(this.requestQueueDelay)));
    }, this.connect = async (e2) => {
      await this.isInitialized();
      const s = b2(g3({}, e2), { requiredNamespaces: e2.requiredNamespaces || {}, optionalNamespaces: e2.optionalNamespaces || {} });
      await this.isValidConnect(s);
      const { pairingTopic: t, requiredNamespaces: i3, optionalNamespaces: n2, sessionProperties: o2, relays: a2 } = s;
      let c2 = t, p4, d4 = false;
      if (c2 && (d4 = this.client.core.pairing.pairings.get(c2).active), !c2 || !d4) {
        const { topic: v2, uri: S4 } = await this.client.core.pairing.create();
        c2 = v2, p4 = S4;
      }
      const h3 = await this.client.core.crypto.generateKeyPair(), R5 = g3({ requiredNamespaces: i3, optionalNamespaces: n2, relays: a2 != null ? a2 : [{ protocol: ot2 }], proposer: { publicKey: h3, metadata: this.client.metadata } }, o2 && { sessionProperties: o2 }), { reject: w4, resolve: T3, done: K4 } = st2(import_time4.FIVE_MINUTES, oe2);
      if (this.events.once(ft2("session_connect"), async ({ error: v2, session: S4 }) => {
        if (v2)
          w4(v2);
        else if (S4) {
          S4.self.publicKey = h3;
          const B4 = b2(g3({}, S4), { requiredNamespaces: S4.requiredNamespaces, optionalNamespaces: S4.optionalNamespaces });
          await this.client.session.set(S4.topic, B4), await this.setExpiry(S4.topic, S4.expiry), c2 && await this.client.core.pairing.updateMetadata({ topic: c2, metadata: S4.peer.metadata }), T3(B4);
        }
      }), !c2) {
        const { message: v2 } = N3("NO_MATCHING_KEY", `connect() pairing topic: ${c2}`);
        throw new Error(v2);
      }
      const L4 = await this.sendRequest({ topic: c2, method: "wc_sessionPropose", params: R5 }), ue4 = lt2(import_time4.FIVE_MINUTES);
      return await this.setProposal(L4, g3({ id: L4, expiry: ue4 }, R5)), { uri: p4, approval: K4 };
    }, this.pair = async (e2) => (await this.isInitialized(), await this.client.core.pairing.pair(e2)), this.approve = async (e2) => {
      await this.isInitialized(), await this.isValidApprove(e2);
      const { id: s, relayProtocol: t, namespaces: i3, sessionProperties: n2 } = e2, o2 = this.client.proposal.get(s);
      let { pairingTopic: a2, proposer: c2, requiredNamespaces: p4, optionalNamespaces: d4 } = o2;
      a2 = a2 || "", B2(p4) || (p4 = At2(i3, "approve()"));
      const h3 = await this.client.core.crypto.generateKeyPair(), R5 = c2.publicKey, w4 = await this.client.core.crypto.generateSharedKey(h3, R5);
      a2 && s && (await this.client.core.pairing.updateMetadata({ topic: a2, metadata: c2.metadata }), await this.sendResult({ id: s, topic: a2, result: { relay: { protocol: t != null ? t : "irn" }, responderPublicKey: h3 } }), await this.client.proposal.delete(s, U2("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: a2 }));
      const T3 = g3({ relay: { protocol: t != null ? t : "irn" }, namespaces: i3, requiredNamespaces: p4, optionalNamespaces: d4, pairingTopic: a2, controller: { publicKey: h3, metadata: this.client.metadata }, expiry: lt2(A2) }, n2 && { sessionProperties: n2 });
      await this.client.core.relayer.subscribe(w4), await this.sendRequest({ topic: w4, method: "wc_sessionSettle", params: T3, throwOnFailedPublish: true });
      const K4 = b2(g3({}, T3), { topic: w4, pairingTopic: a2, acknowledged: false, self: T3.controller, peer: { publicKey: c2.publicKey, metadata: c2.metadata }, controller: h3 });
      return await this.client.session.set(w4, K4), await this.setExpiry(w4, lt2(A2)), { topic: w4, acknowledged: () => new Promise((L4) => setTimeout(() => L4(this.client.session.get(w4)), 500)) };
    }, this.reject = async (e2) => {
      await this.isInitialized(), await this.isValidReject(e2);
      const { id: s, reason: t } = e2, { pairingTopic: i3 } = this.client.proposal.get(s);
      i3 && (await this.sendError(s, i3, t), await this.client.proposal.delete(s, U2("USER_DISCONNECTED")));
    }, this.update = async (e2) => {
      await this.isInitialized(), await this.isValidUpdate(e2);
      const { topic: s, namespaces: t } = e2, i3 = await this.sendRequest({ topic: s, method: "wc_sessionUpdate", params: { namespaces: t } }), { done: n2, resolve: o2, reject: a2 } = st2();
      return this.events.once(ft2("session_update", i3), ({ error: c2 }) => {
        c2 ? a2(c2) : o2();
      }), await this.client.session.update(s, { namespaces: t }), { acknowledged: n2 };
    }, this.extend = async (e2) => {
      await this.isInitialized(), await this.isValidExtend(e2);
      const { topic: s } = e2, t = await this.sendRequest({ topic: s, method: "wc_sessionExtend", params: {} }), { done: i3, resolve: n2, reject: o2 } = st2();
      return this.events.once(ft2("session_extend", t), ({ error: a2 }) => {
        a2 ? o2(a2) : n2();
      }), await this.setExpiry(s, lt2(A2)), { acknowledged: i3 };
    }, this.request = async (e2) => {
      await this.isInitialized(), await this.isValidRequest(e2);
      const { chainId: s, request: t, topic: i3, expiry: n2 } = e2, o2 = payloadId(), { done: a2, resolve: c2, reject: p4 } = st2(n2, "Request expired. Please try again.");
      return this.events.once(ft2("session_request", o2), ({ error: d4, result: h3 }) => {
        d4 ? p4(d4) : c2(h3);
      }), await Promise.all([new Promise(async (d4) => {
        await this.sendRequest({ clientRpcId: o2, topic: i3, method: "wc_sessionRequest", params: { request: t, chainId: s }, expiry: n2, throwOnFailedPublish: true }).catch((h3) => p4(h3)), this.client.events.emit("session_request_sent", { topic: i3, request: t, chainId: s, id: o2 }), d4();
      }), new Promise(async (d4) => {
        const h3 = await this.client.core.storage.getItem(W4);
        pt2({ id: o2, topic: i3, wcDeepLink: h3 }), d4();
      }), a2()]).then((d4) => d4[2]);
    }, this.respond = async (e2) => {
      await this.isInitialized(), await this.isValidRespond(e2);
      const { topic: s, response: t } = e2, { id: i3 } = t;
      isJsonRpcResult(t) ? await this.sendResult({ id: i3, topic: s, result: t.result, throwOnFailedPublish: true }) : isJsonRpcError(t) && await this.sendError(i3, s, t.error), this.cleanupAfterResponse(e2);
    }, this.ping = async (e2) => {
      await this.isInitialized(), await this.isValidPing(e2);
      const { topic: s } = e2;
      if (this.client.session.keys.includes(s)) {
        const t = await this.sendRequest({ topic: s, method: "wc_sessionPing", params: {} }), { done: i3, resolve: n2, reject: o2 } = st2();
        this.events.once(ft2("session_ping", t), ({ error: a2 }) => {
          a2 ? o2(a2) : n2();
        }), await i3();
      } else
        this.client.core.pairing.pairings.keys.includes(s) && await this.client.core.pairing.ping({ topic: s });
    }, this.emit = async (e2) => {
      await this.isInitialized(), await this.isValidEmit(e2);
      const { topic: s, event: t, chainId: i3 } = e2;
      await this.sendRequest({ topic: s, method: "wc_sessionEvent", params: { event: t, chainId: i3 } });
    }, this.disconnect = async (e2) => {
      await this.isInitialized(), await this.isValidDisconnect(e2);
      const { topic: s } = e2;
      this.client.session.keys.includes(s) ? (await this.sendRequest({ topic: s, method: "wc_sessionDelete", params: U2("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession(s)) : await this.client.core.pairing.disconnect({ topic: s });
    }, this.find = (e2) => (this.isInitialized(), this.client.session.getAll().filter((s) => $t3(s, e2))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async (e2) => {
      if (e2.pairingTopic)
        try {
          const s = this.client.core.pairing.pairings.get(e2.pairingTopic), t = this.client.core.pairing.pairings.getAll().filter((i3) => {
            var n2, o2;
            return ((n2 = i3.peerMetadata) == null ? void 0 : n2.url) && ((o2 = i3.peerMetadata) == null ? void 0 : o2.url) === e2.peer.metadata.url && i3.topic && i3.topic !== s.topic;
          });
          if (t.length === 0)
            return;
          this.client.logger.info(`Cleaning up ${t.length} duplicate pairing(s)`), await Promise.all(t.map((i3) => this.client.core.pairing.disconnect({ topic: i3.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
        } catch (s) {
          this.client.logger.error(s);
        }
    }, this.deleteSession = async (e2, s) => {
      const { self: t } = this.client.session.get(e2);
      await this.client.core.relayer.unsubscribe(e2), this.client.session.delete(e2, U2("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(t.publicKey) && await this.client.core.crypto.deleteKeyPair(t.publicKey), this.client.core.crypto.keychain.has(e2) && await this.client.core.crypto.deleteSymKey(e2), s || this.client.core.expirer.del(e2), this.client.core.storage.removeItem(W4).catch((i3) => this.client.logger.warn(i3));
    }, this.deleteProposal = async (e2, s) => {
      await Promise.all([this.client.proposal.delete(e2, U2("USER_DISCONNECTED")), s ? Promise.resolve() : this.client.core.expirer.del(e2)]);
    }, this.deletePendingSessionRequest = async (e2, s, t = false) => {
      await Promise.all([this.client.pendingRequest.delete(e2, s), t ? Promise.resolve() : this.client.core.expirer.del(e2)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i3) => i3.id !== e2), t && (this.sessionRequestQueue.state = I2.idle);
    }, this.setExpiry = async (e2, s) => {
      this.client.session.keys.includes(e2) && await this.client.session.update(e2, { expiry: s }), this.client.core.expirer.set(e2, s);
    }, this.setProposal = async (e2, s) => {
      await this.client.proposal.set(e2, s), this.client.core.expirer.set(e2, s.expiry);
    }, this.setPendingSessionRequest = async (e2) => {
      const s = V5.wc_sessionRequest.req.ttl, { id: t, topic: i3, params: n2, verifyContext: o2 } = e2;
      await this.client.pendingRequest.set(t, { id: t, topic: i3, params: n2, verifyContext: o2 }), s && this.client.core.expirer.set(t, lt2(s));
    }, this.sendRequest = async (e2) => {
      const { topic: s, method: t, params: i3, expiry: n2, relayRpcId: o2, clientRpcId: a2, throwOnFailedPublish: c2 } = e2, p4 = formatJsonRpcRequest(t, i3, a2);
      if (q2() && pe3.includes(t)) {
        const R5 = Mn(JSON.stringify(p4));
        this.client.core.verify.register({ attestationId: R5 });
      }
      const d4 = await this.client.core.crypto.encode(s, p4), h3 = V5[t].req;
      return n2 && (h3.ttl = n2), o2 && (h3.id = o2), this.client.core.history.set(s, p4), c2 ? (h3.internal = b2(g3({}, h3.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s, d4, h3)) : this.client.core.relayer.publish(s, d4, h3).catch((R5) => this.client.logger.error(R5)), p4.id;
    }, this.sendResult = async (e2) => {
      const { id: s, topic: t, result: i3, throwOnFailedPublish: n2 } = e2, o2 = formatJsonRpcResult(s, i3), a2 = await this.client.core.crypto.encode(t, o2), c2 = await this.client.core.history.get(t, s), p4 = V5[c2.request.method].res;
      n2 ? (p4.internal = b2(g3({}, p4.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t, a2, p4)) : this.client.core.relayer.publish(t, a2, p4).catch((d4) => this.client.logger.error(d4)), await this.client.core.history.resolve(o2);
    }, this.sendError = async (e2, s, t) => {
      const i3 = formatJsonRpcError(e2, t), n2 = await this.client.core.crypto.encode(s, i3), o2 = await this.client.core.history.get(s, e2), a2 = V5[o2.request.method].res;
      this.client.core.relayer.publish(s, n2, a2), await this.client.core.history.resolve(i3);
    }, this.cleanup = async () => {
      const e2 = [], s = [];
      this.client.session.getAll().forEach((t) => {
        dt2(t.expiry) && e2.push(t.topic);
      }), this.client.proposal.getAll().forEach((t) => {
        dt2(t.expiry) && s.push(t.id);
      }), await Promise.all([...e2.map((t) => this.deleteSession(t)), ...s.map((t) => this.deleteProposal(t))]);
    }, this.onRelayEventRequest = async (e2) => {
      this.requestQueue.queue.push(e2), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === I2.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = I2.active;
        const e2 = this.requestQueue.queue.shift();
        if (e2)
          try {
            this.processRequest(e2), await new Promise((s) => setTimeout(s, 300));
          } catch (s) {
            this.client.logger.warn(s);
          }
      }
      this.requestQueue.state = I2.idle;
    }, this.processRequest = (e2) => {
      const { topic: s, payload: t } = e2, i3 = t.method;
      switch (i3) {
        case "wc_sessionPropose":
          return this.onSessionProposeRequest(s, t);
        case "wc_sessionSettle":
          return this.onSessionSettleRequest(s, t);
        case "wc_sessionUpdate":
          return this.onSessionUpdateRequest(s, t);
        case "wc_sessionExtend":
          return this.onSessionExtendRequest(s, t);
        case "wc_sessionPing":
          return this.onSessionPingRequest(s, t);
        case "wc_sessionDelete":
          return this.onSessionDeleteRequest(s, t);
        case "wc_sessionRequest":
          return this.onSessionRequest(s, t);
        case "wc_sessionEvent":
          return this.onSessionEventRequest(s, t);
        default:
          return this.client.logger.info(`Unsupported request method ${i3}`);
      }
    }, this.onRelayEventResponse = async (e2) => {
      const { topic: s, payload: t } = e2, i3 = (await this.client.core.history.get(s, t.id)).request.method;
      switch (i3) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(s, t);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(s, t);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(s, t);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(s, t);
        case "wc_sessionPing":
          return this.onSessionPingResponse(s, t);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(s, t);
        default:
          return this.client.logger.info(`Unsupported response method ${i3}`);
      }
    }, this.onRelayEventUnknownPayload = (e2) => {
      const { topic: s } = e2, { message: t } = N3("MISSING_OR_INVALID", `Decoded payload on topic ${s} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(t);
    }, this.onSessionProposeRequest = async (e2, s) => {
      const { params: t, id: i3 } = s;
      try {
        this.isValidConnect(g3({}, s.params));
        const n2 = lt2(import_time4.FIVE_MINUTES), o2 = g3({ id: i3, pairingTopic: e2, expiry: n2 }, t);
        await this.setProposal(i3, o2);
        const a2 = Mn(JSON.stringify(s)), c2 = await this.getVerifyContext(a2, o2.proposer.metadata);
        this.client.events.emit("session_proposal", { id: i3, params: o2, verifyContext: c2 });
      } catch (n2) {
        await this.sendError(i3, e2, n2), this.client.logger.error(n2);
      }
    }, this.onSessionProposeResponse = async (e2, s) => {
      const { id: t } = s;
      if (isJsonRpcResult(s)) {
        const { result: i3 } = s;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: i3 });
        const n2 = this.client.proposal.get(t);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n2 });
        const o2 = n2.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: o2 });
        const a2 = i3.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: a2 });
        const c2 = await this.client.core.crypto.generateSharedKey(o2, a2);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: c2 });
        const p4 = await this.client.core.relayer.subscribe(c2);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: p4 }), await this.client.core.pairing.activate({ topic: e2 });
      } else
        isJsonRpcError(s) && (await this.client.proposal.delete(t, U2("USER_DISCONNECTED")), this.events.emit(ft2("session_connect"), { error: s.error }));
    }, this.onSessionSettleRequest = async (e2, s) => {
      const { id: t, params: i3 } = s;
      try {
        this.isValidSessionSettleRequest(i3);
        const { relay: n2, controller: o2, expiry: a2, namespaces: c2, requiredNamespaces: p4, optionalNamespaces: d4, sessionProperties: h3, pairingTopic: R5 } = s.params, w4 = g3({ topic: e2, relay: n2, expiry: a2, namespaces: c2, acknowledged: true, pairingTopic: R5, requiredNamespaces: p4, optionalNamespaces: d4, controller: o2.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: o2.publicKey, metadata: o2.metadata } }, h3 && { sessionProperties: h3 });
        await this.sendResult({ id: s.id, topic: e2, result: true }), this.events.emit(ft2("session_connect"), { session: w4 }), this.cleanupDuplicatePairings(w4);
      } catch (n2) {
        await this.sendError(t, e2, n2), this.client.logger.error(n2);
      }
    }, this.onSessionSettleResponse = async (e2, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? (await this.client.session.update(e2, { acknowledged: true }), this.events.emit(ft2("session_approve", t), {})) : isJsonRpcError(s) && (await this.client.session.delete(e2, U2("USER_DISCONNECTED")), this.events.emit(ft2("session_approve", t), { error: s.error }));
    }, this.onSessionUpdateRequest = async (e2, s) => {
      const { params: t, id: i3 } = s;
      try {
        const n2 = `${e2}_session_update`, o2 = er2.get(n2);
        if (o2 && this.isRequestOutOfSync(o2, i3)) {
          this.client.logger.info(`Discarding out of sync request - ${i3}`);
          return;
        }
        this.isValidUpdate(g3({ topic: e2 }, t)), await this.client.session.update(e2, { namespaces: t.namespaces }), await this.sendResult({ id: i3, topic: e2, result: true }), this.client.events.emit("session_update", { id: i3, topic: e2, params: t }), er2.set(n2, i3);
      } catch (n2) {
        await this.sendError(i3, e2, n2), this.client.logger.error(n2);
      }
    }, this.isRequestOutOfSync = (e2, s) => parseInt(s.toString().slice(0, -3)) <= parseInt(e2.toString().slice(0, -3)), this.onSessionUpdateResponse = (e2, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? this.events.emit(ft2("session_update", t), {}) : isJsonRpcError(s) && this.events.emit(ft2("session_update", t), { error: s.error });
    }, this.onSessionExtendRequest = async (e2, s) => {
      const { id: t } = s;
      try {
        this.isValidExtend({ topic: e2 }), await this.setExpiry(e2, lt2(A2)), await this.sendResult({ id: t, topic: e2, result: true }), this.client.events.emit("session_extend", { id: t, topic: e2 });
      } catch (i3) {
        await this.sendError(t, e2, i3), this.client.logger.error(i3);
      }
    }, this.onSessionExtendResponse = (e2, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? this.events.emit(ft2("session_extend", t), {}) : isJsonRpcError(s) && this.events.emit(ft2("session_extend", t), { error: s.error });
    }, this.onSessionPingRequest = async (e2, s) => {
      const { id: t } = s;
      try {
        this.isValidPing({ topic: e2 }), await this.sendResult({ id: t, topic: e2, result: true }), this.client.events.emit("session_ping", { id: t, topic: e2 });
      } catch (i3) {
        await this.sendError(t, e2, i3), this.client.logger.error(i3);
      }
    }, this.onSessionPingResponse = (e2, s) => {
      const { id: t } = s;
      setTimeout(() => {
        isJsonRpcResult(s) ? this.events.emit(ft2("session_ping", t), {}) : isJsonRpcError(s) && this.events.emit(ft2("session_ping", t), { error: s.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (e2, s) => {
      const { id: t } = s;
      try {
        this.isValidDisconnect({ topic: e2, reason: s.params }), await Promise.all([new Promise((i3) => {
          this.client.core.relayer.once(D3.publish, async () => {
            i3(await this.deleteSession(e2));
          });
        }), this.sendResult({ id: t, topic: e2, result: true })]), this.client.events.emit("session_delete", { id: t, topic: e2 });
      } catch (i3) {
        this.client.logger.error(i3);
      }
    }, this.onSessionRequest = async (e2, s) => {
      const { id: t, params: i3 } = s;
      try {
        this.isValidRequest(g3({ topic: e2 }, i3));
        const n2 = Mn(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", i3, t))), o2 = this.client.session.get(e2), a2 = await this.getVerifyContext(n2, o2.peer.metadata), c2 = { id: t, topic: e2, params: i3, verifyContext: a2 };
        await this.setPendingSessionRequest(c2), this.addSessionRequestToSessionRequestQueue(c2), this.processSessionRequestQueue();
      } catch (n2) {
        await this.sendError(t, e2, n2), this.client.logger.error(n2);
      }
    }, this.onSessionRequestResponse = (e2, s) => {
      const { id: t } = s;
      isJsonRpcResult(s) ? this.events.emit(ft2("session_request", t), { result: s.result }) : isJsonRpcError(s) && this.events.emit(ft2("session_request", t), { error: s.error });
    }, this.onSessionEventRequest = async (e2, s) => {
      const { id: t, params: i3 } = s;
      try {
        const n2 = `${e2}_session_event_${i3.event.name}`, o2 = er2.get(n2);
        if (o2 && this.isRequestOutOfSync(o2, t)) {
          this.client.logger.info(`Discarding out of sync request - ${t}`);
          return;
        }
        this.isValidEmit(g3({ topic: e2 }, i3)), this.client.events.emit("session_event", { id: t, topic: e2, params: i3 }), er2.set(n2, t);
      } catch (n2) {
        await this.sendError(t, e2, n2), this.client.logger.error(n2);
      }
    }, this.addSessionRequestToSessionRequestQueue = (e2) => {
      this.sessionRequestQueue.queue.push(e2);
    }, this.cleanupAfterResponse = (e2) => {
      this.deletePendingSessionRequest(e2.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = I2.idle, this.processSessionRequestQueue();
      }, (0, import_time4.toMiliseconds)(this.requestQueueDelay));
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === I2.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e2 = this.sessionRequestQueue.queue[0];
      if (!e2) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = I2.active, this.client.events.emit("session_request", e2);
      } catch (s) {
        this.client.logger.error(s);
      }
    }, this.onPairingCreated = (e2) => {
      if (e2.active)
        return;
      const s = this.client.proposal.getAll().find((t) => t.pairingTopic === e2.topic);
      s && this.onSessionProposeRequest(e2.topic, formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: s.requiredNamespaces, optionalNamespaces: s.optionalNamespaces, relays: s.relays, proposer: s.proposer }, s.id));
    }, this.isValidConnect = async (e2) => {
      if (!xt2(e2)) {
        const { message: a2 } = N3("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e2)}`);
        throw new Error(a2);
      }
      const { pairingTopic: s, requiredNamespaces: t, optionalNamespaces: i3, sessionProperties: n2, relays: o2 } = e2;
      if (w(s) || await this.isValidPairingTopic(s), !Kt2(o2, true)) {
        const { message: a2 } = N3("MISSING_OR_INVALID", `connect() relays: ${o2}`);
        throw new Error(a2);
      }
      !w(t) && B2(t) !== 0 && this.validateNamespaces(t, "requiredNamespaces"), !w(i3) && B2(i3) !== 0 && this.validateNamespaces(i3, "optionalNamespaces"), w(n2) || this.validateSessionProps(n2, "sessionProperties");
    }, this.validateNamespaces = (e2, s) => {
      const t = Mt2(e2, "connect()", s);
      if (t)
        throw new Error(t.message);
    }, this.isValidApprove = async (e2) => {
      if (!xt2(e2))
        throw new Error(N3("MISSING_OR_INVALID", `approve() params: ${e2}`).message);
      const { id: s, namespaces: t, relayProtocol: i3, sessionProperties: n2 } = e2;
      await this.isValidProposalId(s);
      const o2 = this.client.proposal.get(s), a2 = cn(t, "approve()");
      if (a2)
        throw new Error(a2.message);
      const c2 = un(o2.requiredNamespaces, t, "approve()");
      if (c2)
        throw new Error(c2.message);
      if (!h2(i3, true)) {
        const { message: p4 } = N3("MISSING_OR_INVALID", `approve() relayProtocol: ${i3}`);
        throw new Error(p4);
      }
      w(n2) || this.validateSessionProps(n2, "sessionProperties");
    }, this.isValidReject = async (e2) => {
      if (!xt2(e2)) {
        const { message: i3 } = N3("MISSING_OR_INVALID", `reject() params: ${e2}`);
        throw new Error(i3);
      }
      const { id: s, reason: t } = e2;
      if (await this.isValidProposalId(s), !Ft2(t)) {
        const { message: i3 } = N3("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(t)}`);
        throw new Error(i3);
      }
    }, this.isValidSessionSettleRequest = (e2) => {
      if (!xt2(e2)) {
        const { message: c2 } = N3("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e2}`);
        throw new Error(c2);
      }
      const { relay: s, controller: t, namespaces: i3, expiry: n2 } = e2;
      if (!an(s)) {
        const { message: c2 } = N3("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(c2);
      }
      const o2 = Vt2(t, "onSessionSettleRequest()");
      if (o2)
        throw new Error(o2.message);
      const a2 = cn(i3, "onSessionSettleRequest()");
      if (a2)
        throw new Error(a2.message);
      if (dt2(n2)) {
        const { message: c2 } = N3("EXPIRED", "onSessionSettleRequest()");
        throw new Error(c2);
      }
    }, this.isValidUpdate = async (e2) => {
      if (!xt2(e2)) {
        const { message: a2 } = N3("MISSING_OR_INVALID", `update() params: ${e2}`);
        throw new Error(a2);
      }
      const { topic: s, namespaces: t } = e2;
      await this.isValidSessionTopic(s);
      const i3 = this.client.session.get(s), n2 = cn(t, "update()");
      if (n2)
        throw new Error(n2.message);
      const o2 = un(i3.requiredNamespaces, t, "update()");
      if (o2)
        throw new Error(o2.message);
    }, this.isValidExtend = async (e2) => {
      if (!xt2(e2)) {
        const { message: t } = N3("MISSING_OR_INVALID", `extend() params: ${e2}`);
        throw new Error(t);
      }
      const { topic: s } = e2;
      await this.isValidSessionTopic(s);
    }, this.isValidRequest = async (e2) => {
      if (!xt2(e2)) {
        const { message: a2 } = N3("MISSING_OR_INVALID", `request() params: ${e2}`);
        throw new Error(a2);
      }
      const { topic: s, request: t, chainId: i3, expiry: n2 } = e2;
      await this.isValidSessionTopic(s);
      const { namespaces: o2 } = this.client.session.get(s);
      if (!Gt2(o2, i3)) {
        const { message: a2 } = N3("MISSING_OR_INVALID", `request() chainId: ${i3}`);
        throw new Error(a2);
      }
      if (!Ht2(t)) {
        const { message: a2 } = N3("MISSING_OR_INVALID", `request() ${JSON.stringify(t)}`);
        throw new Error(a2);
      }
      if (!Wt2(o2, i3, t.method)) {
        const { message: a2 } = N3("MISSING_OR_INVALID", `request() method: ${t.method}`);
        throw new Error(a2);
      }
      if (n2 && !Qt3(n2, U4)) {
        const { message: a2 } = N3("MISSING_OR_INVALID", `request() expiry: ${n2}. Expiry must be a number (in seconds) between ${U4.min} and ${U4.max}`);
        throw new Error(a2);
      }
    }, this.isValidRespond = async (e2) => {
      if (!xt2(e2)) {
        const { message: i3 } = N3("MISSING_OR_INVALID", `respond() params: ${e2}`);
        throw new Error(i3);
      }
      const { topic: s, response: t } = e2;
      if (await this.isValidSessionTopic(s), !qt2(t)) {
        const { message: i3 } = N3("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(t)}`);
        throw new Error(i3);
      }
    }, this.isValidPing = async (e2) => {
      if (!xt2(e2)) {
        const { message: t } = N3("MISSING_OR_INVALID", `ping() params: ${e2}`);
        throw new Error(t);
      }
      const { topic: s } = e2;
      await this.isValidSessionOrPairingTopic(s);
    }, this.isValidEmit = async (e2) => {
      if (!xt2(e2)) {
        const { message: o2 } = N3("MISSING_OR_INVALID", `emit() params: ${e2}`);
        throw new Error(o2);
      }
      const { topic: s, event: t, chainId: i3 } = e2;
      await this.isValidSessionTopic(s);
      const { namespaces: n2 } = this.client.session.get(s);
      if (!Gt2(n2, i3)) {
        const { message: o2 } = N3("MISSING_OR_INVALID", `emit() chainId: ${i3}`);
        throw new Error(o2);
      }
      if (!Bt2(t)) {
        const { message: o2 } = N3("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t)}`);
        throw new Error(o2);
      }
      if (!zt2(n2, i3, t.name)) {
        const { message: o2 } = N3("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t)}`);
        throw new Error(o2);
      }
    }, this.isValidDisconnect = async (e2) => {
      if (!xt2(e2)) {
        const { message: t } = N3("MISSING_OR_INVALID", `disconnect() params: ${e2}`);
        throw new Error(t);
      }
      const { topic: s } = e2;
      await this.isValidSessionOrPairingTopic(s);
    }, this.getVerifyContext = async (e2, s) => {
      const t = { verified: { verifyUrl: s.verifyUrl || $3, validation: "UNKNOWN", origin: s.url || "" } };
      try {
        const i3 = await this.client.core.verify.resolve({ attestationId: e2, verifyUrl: s.verifyUrl });
        i3 && (t.verified.origin = i3.origin, t.verified.isScam = i3.isScam, t.verified.validation = i3.origin === new URL(s.url).origin ? "VALID" : "INVALID");
      } catch (i3) {
        this.client.logger.info(i3);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(t)}`), t;
    }, this.validateSessionProps = (e2, s) => {
      Object.values(e2).forEach((t) => {
        if (!h2(t, false)) {
          const { message: i3 } = N3("MISSING_OR_INVALID", `${s} must be in Record<string, string> format. Received: ${JSON.stringify(t)}`);
          throw new Error(i3);
        }
      });
    };
  }
  async isInitialized() {
    if (!this.initialized) {
      const { message: r } = N3("NOT_INITIALIZED", this.name);
      throw new Error(r);
    }
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(D3.message, async (r) => {
      const { topic: e2, message: s } = r;
      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s)))
        return;
      const t = await this.client.core.crypto.decode(e2, s);
      try {
        isJsonRpcRequest(t) ? (this.client.core.history.set(e2, t), this.onRelayEventRequest({ topic: e2, payload: t })) : isJsonRpcResponse(t) ? (await this.client.core.history.resolve(t), await this.onRelayEventResponse({ topic: e2, payload: t }), this.client.core.history.delete(e2, t.id)) : this.onRelayEventUnknownPayload({ topic: e2, payload: t });
      } catch (i3) {
        this.client.logger.error(i3);
      }
    });
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(v.expired, async (r) => {
      const { topic: e2, id: s } = ut2(r.target);
      if (s && this.client.pendingRequest.keys.includes(s))
        return await this.deletePendingSessionRequest(s, N3("EXPIRED"), true);
      e2 ? this.client.session.keys.includes(e2) && (await this.deleteSession(e2, true), this.client.events.emit("session_expire", { topic: e2 })) : s && (await this.deleteProposal(s, true), this.client.events.emit("proposal_expire", { id: s }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(V4.create, (r) => this.onPairingCreated(r));
  }
  isValidPairingTopic(r) {
    if (!h2(r, false)) {
      const { message: e2 } = N3("MISSING_OR_INVALID", `pairing topic should be a string: ${r}`);
      throw new Error(e2);
    }
    if (!this.client.core.pairing.pairings.keys.includes(r)) {
      const { message: e2 } = N3("NO_MATCHING_KEY", `pairing topic doesn't exist: ${r}`);
      throw new Error(e2);
    }
    if (dt2(this.client.core.pairing.pairings.get(r).expiry)) {
      const { message: e2 } = N3("EXPIRED", `pairing topic: ${r}`);
      throw new Error(e2);
    }
  }
  async isValidSessionTopic(r) {
    if (!h2(r, false)) {
      const { message: e2 } = N3("MISSING_OR_INVALID", `session topic should be a string: ${r}`);
      throw new Error(e2);
    }
    if (!this.client.session.keys.includes(r)) {
      const { message: e2 } = N3("NO_MATCHING_KEY", `session topic doesn't exist: ${r}`);
      throw new Error(e2);
    }
    if (dt2(this.client.session.get(r).expiry)) {
      await this.deleteSession(r);
      const { message: e2 } = N3("EXPIRED", `session topic: ${r}`);
      throw new Error(e2);
    }
  }
  async isValidSessionOrPairingTopic(r) {
    if (this.client.session.keys.includes(r))
      await this.isValidSessionTopic(r);
    else if (this.client.core.pairing.pairings.keys.includes(r))
      this.isValidPairingTopic(r);
    else if (h2(r, false)) {
      const { message: e2 } = N3("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${r}`);
      throw new Error(e2);
    } else {
      const { message: e2 } = N3("MISSING_OR_INVALID", `session or pairing topic should be a string: ${r}`);
      throw new Error(e2);
    }
  }
  async isValidProposalId(r) {
    if (!Lt2(r)) {
      const { message: e2 } = N3("MISSING_OR_INVALID", `proposal id should be a number: ${r}`);
      throw new Error(e2);
    }
    if (!this.client.proposal.keys.includes(r)) {
      const { message: e2 } = N3("NO_MATCHING_KEY", `proposal id doesn't exist: ${r}`);
      throw new Error(e2);
    }
    if (dt2(this.client.proposal.get(r).expiry)) {
      await this.deleteProposal(r);
      const { message: e2 } = N3("EXPIRED", `proposal id: ${r}`);
      throw new Error(e2);
    }
  }
};
var hs2 = class extends $t4 {
  constructor(r, e2) {
    super(r, e2, ne2, G3), this.core = r, this.logger = e2;
  }
};
var ds2 = class extends $t4 {
  constructor(r, e2) {
    super(r, e2, ae3, G3), this.core = r, this.logger = e2;
  }
};
var us2 = class extends $t4 {
  constructor(r, e2) {
    super(r, e2, le4, G3, (s) => s.id), this.core = r, this.logger = e2;
  }
};
var Q4 = class extends b {
  constructor(r) {
    super(r), this.protocol = X3, this.version = F4, this.name = M2.name, this.events = new import_events5.EventEmitter(), this.on = (s, t) => this.events.on(s, t), this.once = (s, t) => this.events.once(s, t), this.off = (s, t) => this.events.off(s, t), this.removeListener = (s, t) => this.events.removeListener(s, t), this.removeAllListeners = (s) => this.events.removeAllListeners(s), this.connect = async (s) => {
      try {
        return await this.engine.connect(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.pair = async (s) => {
      try {
        return await this.engine.pair(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.approve = async (s) => {
      try {
        return await this.engine.approve(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.reject = async (s) => {
      try {
        return await this.engine.reject(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.update = async (s) => {
      try {
        return await this.engine.update(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.extend = async (s) => {
      try {
        return await this.engine.extend(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.request = async (s) => {
      try {
        return await this.engine.request(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.respond = async (s) => {
      try {
        return await this.engine.respond(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.ping = async (s) => {
      try {
        return await this.engine.ping(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.emit = async (s) => {
      try {
        return await this.engine.emit(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.disconnect = async (s) => {
      try {
        return await this.engine.disconnect(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.find = (s) => {
      try {
        return this.engine.find(s);
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.name = (r == null ? void 0 : r.name) || M2.name, this.metadata = (r == null ? void 0 : r.metadata) || zn();
    const e2 = typeof (r == null ? void 0 : r.logger) < "u" && typeof (r == null ? void 0 : r.logger) != "string" ? r.logger : (0, import_logger3.pino)((0, import_logger3.getDefaultLoggerOptions)({ level: (r == null ? void 0 : r.logger) || M2.logger }));
    this.core = (r == null ? void 0 : r.core) || new zr3(r), this.logger = (0, import_logger3.generateChildLogger)(e2, this.name), this.session = new ds2(this.core, this.logger), this.proposal = new hs2(this.core, this.logger), this.pendingRequest = new us2(this.core, this.logger), this.engine = new ps2(this);
  }
  static async init(r) {
    const e2 = new Q4(r);
    return await e2.initialize(), e2;
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info("SignClient Initialization Success");
    } catch (r) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(r.message), r;
    }
  }
};
var gs2 = Q4;

// node_modules/@walletconnect/web3wallet/dist/index.es.js
var l = { exports: {} };
var u2 = typeof Reflect == "object" ? Reflect : null;
var m2 = u2 && typeof u2.apply == "function" ? u2.apply : function(t, e2, n2) {
  return Function.prototype.apply.call(t, e2, n2);
};
var f2;
u2 && typeof u2.ownKeys == "function" ? f2 = u2.ownKeys : Object.getOwnPropertySymbols ? f2 = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : f2 = function(t) {
  return Object.getOwnPropertyNames(t);
};
function T2(s) {
  console && console.warn && console.warn(s);
}
var y3 = Number.isNaN || function(t) {
  return t !== t;
};
function o() {
  o.init.call(this);
}
l.exports = o, l.exports.once = M3, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
var w3 = 10;
function g4(s) {
  if (typeof s != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof s);
}
Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
  return w3;
}, set: function(s) {
  if (typeof s != "number" || s < 0 || y3(s))
    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + s + ".");
  w3 = s;
} }), o.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, o.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || y3(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function L3(s) {
  return s._maxListeners === void 0 ? o.defaultMaxListeners : s._maxListeners;
}
o.prototype.getMaxListeners = function() {
  return L3(this);
}, o.prototype.emit = function(t) {
  for (var e2 = [], n2 = 1; n2 < arguments.length; n2++)
    e2.push(arguments[n2]);
  var i3 = t === "error", a2 = this._events;
  if (a2 !== void 0)
    i3 = i3 && a2.error === void 0;
  else if (!i3)
    return false;
  if (i3) {
    var r;
    if (e2.length > 0 && (r = e2[0]), r instanceof Error)
      throw r;
    var h3 = new Error("Unhandled error." + (r ? " (" + r.message + ")" : ""));
    throw h3.context = r, h3;
  }
  var c2 = a2[t];
  if (c2 === void 0)
    return false;
  if (typeof c2 == "function")
    m2(c2, this, e2);
  else
    for (var v2 = c2.length, A3 = b3(c2, v2), n2 = 0; n2 < v2; ++n2)
      m2(A3[n2], this, e2);
  return true;
};
function _3(s, t, e2, n2) {
  var i3, a2, r;
  if (g4(e2), a2 = s._events, a2 === void 0 ? (a2 = s._events = /* @__PURE__ */ Object.create(null), s._eventsCount = 0) : (a2.newListener !== void 0 && (s.emit("newListener", t, e2.listener ? e2.listener : e2), a2 = s._events), r = a2[t]), r === void 0)
    r = a2[t] = e2, ++s._eventsCount;
  else if (typeof r == "function" ? r = a2[t] = n2 ? [e2, r] : [r, e2] : n2 ? r.unshift(e2) : r.push(e2), i3 = L3(s), i3 > 0 && r.length > i3 && !r.warned) {
    r.warned = true;
    var h3 = new Error("Possible EventEmitter memory leak detected. " + r.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    h3.name = "MaxListenersExceededWarning", h3.emitter = s, h3.type = t, h3.count = r.length, T2(h3);
  }
  return s;
}
o.prototype.addListener = function(t, e2) {
  return _3(this, t, e2, false);
}, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(t, e2) {
  return _3(this, t, e2, true);
};
function j3() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function S3(s, t, e2) {
  var n2 = { fired: false, wrapFn: void 0, target: s, type: t, listener: e2 }, i3 = j3.bind(n2);
  return i3.listener = e2, n2.wrapFn = i3, i3;
}
o.prototype.once = function(t, e2) {
  return g4(e2), this.on(t, S3(this, t, e2)), this;
}, o.prototype.prependOnceListener = function(t, e2) {
  return g4(e2), this.prependListener(t, S3(this, t, e2)), this;
}, o.prototype.removeListener = function(t, e2) {
  var n2, i3, a2, r, h3;
  if (g4(e2), i3 = this._events, i3 === void 0)
    return this;
  if (n2 = i3[t], n2 === void 0)
    return this;
  if (n2 === e2 || n2.listener === e2)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i3[t], i3.removeListener && this.emit("removeListener", t, n2.listener || e2));
  else if (typeof n2 != "function") {
    for (a2 = -1, r = n2.length - 1; r >= 0; r--)
      if (n2[r] === e2 || n2[r].listener === e2) {
        h3 = n2[r].listener, a2 = r;
        break;
      }
    if (a2 < 0)
      return this;
    a2 === 0 ? n2.shift() : I3(n2, a2), n2.length === 1 && (i3[t] = n2[0]), i3.removeListener !== void 0 && this.emit("removeListener", t, h3 || e2);
  }
  return this;
}, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(t) {
  var e2, n2, i3;
  if (n2 = this._events, n2 === void 0)
    return this;
  if (n2.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n2[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n2[t]), this;
  if (arguments.length === 0) {
    var a2 = Object.keys(n2), r;
    for (i3 = 0; i3 < a2.length; ++i3)
      r = a2[i3], r !== "removeListener" && this.removeAllListeners(r);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (e2 = n2[t], typeof e2 == "function")
    this.removeListener(t, e2);
  else if (e2 !== void 0)
    for (i3 = e2.length - 1; i3 >= 0; i3--)
      this.removeListener(t, e2[i3]);
  return this;
};
function C(s, t, e2) {
  var n2 = s._events;
  if (n2 === void 0)
    return [];
  var i3 = n2[t];
  return i3 === void 0 ? [] : typeof i3 == "function" ? e2 ? [i3.listener || i3] : [i3] : e2 ? W5(i3) : b3(i3, i3.length);
}
o.prototype.listeners = function(t) {
  return C(this, t, true);
}, o.prototype.rawListeners = function(t) {
  return C(this, t, false);
}, o.listenerCount = function(s, t) {
  return typeof s.listenerCount == "function" ? s.listenerCount(t) : E3.call(s, t);
}, o.prototype.listenerCount = E3;
function E3(s) {
  var t = this._events;
  if (t !== void 0) {
    var e2 = t[s];
    if (typeof e2 == "function")
      return 1;
    if (e2 !== void 0)
      return e2.length;
  }
  return 0;
}
o.prototype.eventNames = function() {
  return this._eventsCount > 0 ? f2(this._events) : [];
};
function b3(s, t) {
  for (var e2 = new Array(t), n2 = 0; n2 < t; ++n2)
    e2[n2] = s[n2];
  return e2;
}
function I3(s, t) {
  for (; t + 1 < s.length; t++)
    s[t] = s[t + 1];
  s.pop();
}
function W5(s) {
  for (var t = new Array(s.length), e2 = 0; e2 < t.length; ++e2)
    t[e2] = s[e2].listener || s[e2];
  return t;
}
function M3(s, t) {
  return new Promise(function(e2, n2) {
    function i3(r) {
      s.removeListener(t, a2), n2(r);
    }
    function a2() {
      typeof s.removeListener == "function" && s.removeListener("error", i3), e2([].slice.call(arguments));
    }
    R4(s, t, a2, { once: true }), t !== "error" && z2(s, i3, { once: true });
  });
}
function z2(s, t, e2) {
  typeof s.on == "function" && R4(s, "error", t, e2);
}
function R4(s, t, e2, n2) {
  if (typeof s.on == "function")
    n2.once ? s.once(t, e2) : s.on(t, e2);
  else if (typeof s.addEventListener == "function")
    s.addEventListener(t, function i3(a2) {
      n2.once && s.removeEventListener(t, i3), e2(a2);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof s);
}
var O5 = "wc";
var d3 = "Web3Wallet";
var K3 = `${O5}@2:${d3}:`;
var X4 = class extends l.exports {
  constructor() {
    super();
  }
};
var x3 = class {
  constructor(t) {
    this.opts = t;
  }
};
var P2 = class {
  constructor(t) {
    this.client = t;
  }
};
var D4 = class extends P2 {
  constructor(t) {
    super(t), this.init = async () => {
      this.signClient = await gs2.init({ core: this.client.core, metadata: this.client.metadata }), this.authClient = await zr2.init({ core: this.client.core, projectId: "", metadata: this.client.metadata }), this.initializeEventListeners();
    }, this.pair = async (e2) => {
      await this.client.core.pairing.pair(e2);
    }, this.approveSession = async (e2) => {
      const { topic: n2, acknowledged: i3 } = await this.signClient.approve({ id: e2.id, namespaces: e2.namespaces });
      return await i3(), this.signClient.session.get(n2);
    }, this.rejectSession = async (e2) => await this.signClient.reject(e2), this.updateSession = async (e2) => await (await this.signClient.update(e2)).acknowledged(), this.extendSession = async (e2) => await (await this.signClient.extend(e2)).acknowledged(), this.respondSessionRequest = async (e2) => await this.signClient.respond(e2), this.disconnectSession = async (e2) => await this.signClient.disconnect(e2), this.emitSessionEvent = async (e2) => await this.signClient.emit(e2), this.getActiveSessions = () => this.signClient.session.getAll().reduce((e2, n2) => (e2[n2.topic] = n2, e2), {}), this.getPendingSessionProposals = () => this.signClient.proposal.getAll(), this.getPendingSessionRequests = () => this.signClient.getPendingSessionRequests(), this.respondAuthRequest = async (e2, n2) => await this.authClient.respond(e2, n2), this.getPendingAuthRequests = () => this.authClient.requests.getAll().filter((e2) => "requester" in e2), this.formatMessage = (e2, n2) => this.authClient.formatMessage(e2, n2), this.onSessionRequest = (e2) => {
      this.client.events.emit("session_request", e2);
    }, this.onSessionProposal = (e2) => {
      this.client.events.emit("session_proposal", e2);
    }, this.onSessionDelete = (e2) => {
      this.client.events.emit("session_delete", e2);
    }, this.onAuthRequest = (e2) => {
      this.client.events.emit("auth_request", e2);
    }, this.initializeEventListeners = () => {
      this.signClient.events.on("session_proposal", this.onSessionProposal), this.signClient.events.on("session_request", this.onSessionRequest), this.signClient.events.on("session_delete", this.onSessionDelete), this.authClient.on("auth_request", this.onAuthRequest);
    }, this.signClient = {}, this.authClient = {};
  }
};
var p3 = class extends x3 {
  constructor(t) {
    super(t), this.events = new l.exports(), this.on = (e2, n2) => this.events.on(e2, n2), this.once = (e2, n2) => this.events.once(e2, n2), this.off = (e2, n2) => this.events.off(e2, n2), this.removeListener = (e2, n2) => this.events.removeListener(e2, n2), this.pair = async (e2) => {
      try {
        return await this.engine.pair(e2);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.approveSession = async (e2) => {
      try {
        return await this.engine.approveSession(e2);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.rejectSession = async (e2) => {
      try {
        return await this.engine.rejectSession(e2);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.updateSession = async (e2) => {
      try {
        return await this.engine.updateSession(e2);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.extendSession = async (e2) => {
      try {
        return await this.engine.extendSession(e2);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.respondSessionRequest = async (e2) => {
      try {
        return await this.engine.respondSessionRequest(e2);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.disconnectSession = async (e2) => {
      try {
        return await this.engine.disconnectSession(e2);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.emitSessionEvent = async (e2) => {
      try {
        return await this.engine.emitSessionEvent(e2);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.getActiveSessions = () => {
      try {
        return this.engine.getActiveSessions();
      } catch (e2) {
        throw this.logger.error(e2.message), e2;
      }
    }, this.getPendingSessionProposals = () => {
      try {
        return this.engine.getPendingSessionProposals();
      } catch (e2) {
        throw this.logger.error(e2.message), e2;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (e2) {
        throw this.logger.error(e2.message), e2;
      }
    }, this.respondAuthRequest = async (e2, n2) => {
      try {
        return await this.engine.respondAuthRequest(e2, n2);
      } catch (i3) {
        throw this.logger.error(i3.message), i3;
      }
    }, this.getPendingAuthRequests = () => {
      try {
        return this.engine.getPendingAuthRequests();
      } catch (e2) {
        throw this.logger.error(e2.message), e2;
      }
    }, this.formatMessage = (e2, n2) => {
      try {
        return this.engine.formatMessage(e2, n2);
      } catch (i3) {
        throw this.logger.error(i3.message), i3;
      }
    }, this.metadata = t.metadata, this.name = t.name || d3, this.core = t.core, this.logger = this.core.logger, this.engine = new D4(this);
  }
  static async init(t) {
    const e2 = new p3(t);
    return await e2.initialize(), e2;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.engine.init(), this.logger.info("Web3Wallet Initialization Success");
    } catch (t) {
      throw this.logger.info("Web3Wallet Initialization Failure"), this.logger.error(t.message), t;
    }
  }
};
var G4 = p3;

// node_modules/@thirdweb-dev/wallets/dist/smart-wallet-87ec1d05.browser.esm.js
init_lib3();

// node_modules/@thirdweb-dev/wallets/dist/wc-c6a6a61c.browser.esm.js
init_shim();
var TW_WC_PROJECT_ID = "145769e410f16970a79ff77b2d89a1e0";
var WC_RELAY_URL = "wss://relay.walletconnect.com";
var EIP155_SIGNING_METHODS = {
  PERSONAL_SIGN: "personal_sign",
  ETH_SIGN: "eth_sign",
  ETH_SIGN_TRANSACTION: "eth_signTransaction",
  ETH_SIGN_TYPED_DATA: "eth_signTypedData",
  ETH_SIGN_TYPED_DATA_V3: "eth_signTypedData_v3",
  ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
  ETH_SEND_TRANSACTION: "eth_sendTransaction",
  SWITCH_CHAIN: "wallet_switchEthereumChain"
};

// node_modules/@thirdweb-dev/wallets/dist/smart-wallet-87ec1d05.browser.esm.js
var WalletConnectHandler = class extends eventemitter3_default {
};
var _core = /* @__PURE__ */ new WeakMap();
var _wcWallet = /* @__PURE__ */ new WeakMap();
var _session = /* @__PURE__ */ new WeakMap();
var _wcMetadata = /* @__PURE__ */ new WeakMap();
var _activeProposal = /* @__PURE__ */ new WeakMap();
var _activeRequestEvent = /* @__PURE__ */ new WeakMap();
var _setupWalletConnectEventsListeners = /* @__PURE__ */ new WeakSet();
var _getSignParamsMessage = /* @__PURE__ */ new WeakSet();
var WalletConnectV2Handler = class extends WalletConnectHandler {
  constructor(options) {
    super();
    _classPrivateMethodInitSpec(this, _getSignParamsMessage);
    _classPrivateMethodInitSpec(this, _setupWalletConnectEventsListeners);
    _classPrivateFieldInitSpec(this, _core, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _wcWallet, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _session, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _wcMetadata, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _activeProposal, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _activeRequestEvent, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _wcMetadata, (options == null ? void 0 : options.walletConnectWalletMetadata) || {
      name: "Thirdweb Smart Wallet",
      description: "Thirdweb Smart Wallet",
      url: "https://thirdweb.com",
      icons: ["https://thirdweb.com/favicon.ico"]
    });
    _classPrivateFieldSet(this, _core, new zr({
      projectId: (options == null ? void 0 : options.walletConnectV2ProjectId) || TW_WC_PROJECT_ID,
      relayUrl: (options == null ? void 0 : options.walletConnectV2RelayUrl) || WC_RELAY_URL
    }));
  }
  async init() {
    _classPrivateFieldSet(this, _wcWallet, await G4.init({
      core: _classPrivateFieldGet(this, _core),
      metadata: _classPrivateFieldGet(this, _wcMetadata)
    }));
    const sessions = _classPrivateFieldGet(this, _wcWallet).getActiveSessions();
    const keys = Object.keys(sessions);
    if (keys[0]) {
      _classPrivateFieldSet(this, _session, sessions[keys[0]]);
    }
    _classPrivateMethodGet(this, _setupWalletConnectEventsListeners, _setupWalletConnectEventsListeners2).call(this);
  }
  async connectApp(wcUri) {
    if (!_classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before connecting an app.");
    }
    await _classPrivateFieldGet(this, _wcWallet).core.pairing.pair({
      uri: wcUri
    });
  }
  async approveSession(wallet) {
    var _a;
    if (!_classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!_classPrivateFieldGet(this, _activeProposal)) {
      throw new Error("Please, pass a valid proposal.");
    }
    const account = await wallet.getAddress();
    const {
      id,
      params
    } = _classPrivateFieldGet(this, _activeProposal);
    const {
      requiredNamespaces,
      relays
    } = params;
    const namespaces = {};
    Object.keys(requiredNamespaces).forEach((key) => {
      var _a2;
      const accounts = [];
      const namespace = requiredNamespaces[key];
      if (namespace) {
        (_a2 = namespace.chains) == null ? void 0 : _a2.map((chain) => {
          accounts.push(`${chain}:${account}`);
        });
        namespaces[key] = {
          accounts,
          methods: namespace.methods,
          events: namespace.events
        };
      }
    });
    _classPrivateFieldSet(this, _session, await _classPrivateFieldGet(this, _wcWallet).approveSession({
      id,
      relayProtocol: (_a = relays[0]) == null ? void 0 : _a.protocol,
      namespaces
    }));
    this.emit("session_approved");
  }
  async rejectSession() {
    if (!_classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!_classPrivateFieldGet(this, _activeProposal)) {
      throw new Error("Please, pass a valid proposal.");
    }
    const {
      id
    } = _classPrivateFieldGet(this, _activeProposal);
    await _classPrivateFieldGet(this, _wcWallet).rejectSession({
      id,
      reason: {
        message: "User rejected methods.",
        code: 5002
      }
    });
  }
  async approveEIP155Request(wallet) {
    var _a, _b;
    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {
      return;
    }
    const {
      topic,
      params,
      id
    } = _classPrivateFieldGet(this, _activeRequestEvent);
    const {
      request
    } = params;
    let response;
    switch (request.method) {
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
      case EIP155_SIGNING_METHODS.ETH_SIGN:
        const message = _classPrivateMethodGet(this, _getSignParamsMessage, _getSignParamsMessage2).call(this, request.params);
        const signedMessage = await wallet.signMessage(message || "");
        response = formatJsonRpcResult(id, signedMessage);
        break;
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
        const signer = await wallet.getSigner();
        const sendTransaction = request.params[0];
        const tx = await signer.sendTransaction(sendTransaction);
        const {
          transactionHash
        } = await tx.wait();
        response = formatJsonRpcResult(id, transactionHash);
        break;
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        const signerSign = await wallet.getSigner();
        const signTransaction = request.params[0];
        const signature = await signerSign.signTransaction(signTransaction);
        response = formatJsonRpcResult(id, signature);
        break;
      default:
        const error = {
          id,
          jsonrpc: "2.0",
          error: {
            message: "Invalid event.",
            code: 1002
          }
        };
        return (_a = _classPrivateFieldGet(this, _wcWallet)) == null ? void 0 : _a.respondSessionRequest({
          topic,
          response: error
        });
    }
    return (_b = _classPrivateFieldGet(this, _wcWallet)) == null ? void 0 : _b.respondSessionRequest({
      topic,
      response
    });
  }
  async rejectEIP155Request() {
    var _a;
    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {
      return;
    }
    const {
      topic,
      id
    } = _classPrivateFieldGet(this, _activeRequestEvent);
    const response = {
      id,
      jsonrpc: "2.0",
      error: {
        message: "User rejected methods.",
        code: 5002
      }
    };
    return (_a = _classPrivateFieldGet(this, _wcWallet)) == null ? void 0 : _a.respondSessionRequest({
      topic,
      response
    });
  }
  getActiveSessions() {
    if (!_classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before getting sessions.");
    }
    const sessions = _classPrivateFieldGet(this, _wcWallet).getActiveSessions();
    const sessionKeys = Object.keys(sessions);
    if (!sessions || sessionKeys.length === 0) {
      return [];
    }
    const thisSessions = [];
    for (const sessionKey of sessionKeys) {
      const session = sessions[sessionKey];
      if (session) {
        const topic = session.topic;
        const peerMeta = session.peer.metadata;
        thisSessions.push({
          topic,
          peer: {
            metadata: peerMeta
          }
        });
      }
    }
    return thisSessions;
  }
  disconnectSession() {
    var _a;
    if (!_classPrivateFieldGet(this, _wcWallet)) {
      throw new Error("Please, init the wallet before disconnecting sessions.");
    }
    if (!_classPrivateFieldGet(this, _session)) {
      return Promise.resolve();
    }
    const params = {
      topic: _classPrivateFieldGet(this, _session).topic,
      reason: {
        message: "User disconnected.",
        code: 6e3
      }
    };
    return (_a = _classPrivateFieldGet(this, _wcWallet)) == null ? void 0 : _a.disconnectSession(params);
  }
};
function _setupWalletConnectEventsListeners2() {
  if (!_classPrivateFieldGet(this, _wcWallet)) {
    throw new Error("Please, init the wallet before making session requests.");
  }
  _classPrivateFieldGet(this, _wcWallet).on("session_proposal", (proposal) => {
    _classPrivateFieldSet(this, _activeProposal, proposal);
    this.emit("session_proposal", {
      proposer: {
        metadata: proposal.params.proposer.metadata
      }
    });
  });
  _classPrivateFieldGet(this, _wcWallet).on("session_delete", (session) => {
    _classPrivateFieldSet(this, _session, void 0);
    _classPrivateFieldSet(this, _activeProposal, void 0);
    this.emit("session_delete", {
      topic: session.topic
    });
  });
  _classPrivateFieldGet(this, _wcWallet).on("session_request", async (requestEvent) => {
    if (!_classPrivateFieldGet(this, _session)) {
      return;
    }
    const {
      params: requestParams
    } = requestEvent;
    const {
      request
    } = requestParams;
    const {
      params
    } = request;
    switch (request.method) {
      case EIP155_SIGNING_METHODS.ETH_SIGN:
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);
        const message = params[0];
        const decodedMessage = new TextDecoder().decode(utils_exports.arrayify(message));
        const paramsCopy = [...params];
        paramsCopy[0] = decodedMessage;
        this.emit("session_request", {
          topic: _classPrivateFieldGet(this, _session).topic,
          params: paramsCopy,
          peer: {
            metadata: _classPrivateFieldGet(this, _session).peer.metadata
          },
          method: request.method
        });
        return;
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);
        this.emit("session_request", {
          topic: _classPrivateFieldGet(this, _session).topic,
          params: requestEvent.params.request.params,
          peer: {
            metadata: _classPrivateFieldGet(this, _session).peer.metadata
          },
          method: request.method
        });
        return;
      default:
        throw new Error(`WCV2.Method not supported: ${request.method}`);
    }
  });
}
function _getSignParamsMessage2(params) {
  const message = params.filter((p4) => !utils_exports.isAddress(p4))[0] || "";
  if (utils_exports.isHexString(message)) {
    return utils_exports.toUtf8String(message);
  }
  return message;
}
var NoOpWalletConnectHandler = class extends WalletConnectHandler {
  init() {
    return Promise.resolve();
  }
  connectApp(uri) {
    return Promise.resolve();
  }
  approveSession(wallet) {
    return Promise.resolve();
  }
  rejectSession() {
    return Promise.resolve();
  }
  approveEIP155Request(wallet) {
    return Promise.resolve();
  }
  rejectEIP155Request() {
    return Promise.resolve();
  }
  getActiveSessions() {
    return [];
  }
  disconnectSession() {
    return Promise.resolve();
  }
};
var SmartWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Smart Wallet";
  }
  constructor(options) {
    if (options.clientId && typeof options.chain === "object") {
      try {
        options.chain = {
          ...options.chain,
          rpc: getValidChainRPCs(options.chain, options.clientId)
        };
      } catch {
      }
    }
    super(SmartWallet.id, {
      ...options
    });
    _defineProperty(this, "enableConnectApp", false);
    this.enableConnectApp = (options == null ? void 0 : options.enableConnectApp) || false;
    this.wcWallet = this.enableConnectApp ? new WalletConnectV2Handler({
      walletConnectWalletMetadata: options == null ? void 0 : options.walletConnectWalletMetadata,
      walletConnectV2ProjectId: options == null ? void 0 : options.walletConnectV2ProjectId,
      walletConnectV2RelayUrl: options == null ? void 0 : options.walletConnectV2RelayUrl
    }) : new NoOpWalletConnectHandler();
  }
  async getConnector() {
    if (!this.connector) {
      if (this.enableConnectApp) {
        await this.wcWallet.init();
        this.setupWalletConnectEventsListeners();
      }
      const {
        SmartWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm-OOTBCIF3.js");
      this.connector = new SmartWalletConnector(this.options);
    }
    return this.connector;
  }
  getPersonalWallet() {
    var _a;
    return (_a = this.connector) == null ? void 0 : _a.personalWallet;
  }
  async hasPermissionToExecute(transaction) {
    const connector = await this.getConnector();
    return connector.hasPermissionToExecute(transaction);
  }
  async send(transaction) {
    const connector = await this.getConnector();
    return connector.send(transaction);
  }
  async execute(transaction) {
    const connector = await this.getConnector();
    return connector.execute(transaction);
  }
  async sendBatch(transactions) {
    const connector = await this.getConnector();
    return connector.sendBatch(transactions);
  }
  async executeBatch(transactions) {
    const connector = await this.getConnector();
    return connector.executeBatch(transactions);
  }
  async sendRaw(transaction) {
    const connector = await this.getConnector();
    return connector.sendRaw(transaction);
  }
  async executeRaw(transaction) {
    const connector = await this.getConnector();
    return connector.executeRaw(transaction);
  }
  async estimate(transaction) {
    const connector = await this.getConnector();
    return connector.estimate(transaction);
  }
  async estimateBatch(transactions) {
    const connector = await this.getConnector();
    return connector.estimateBatch(transactions);
  }
  async estimateRaw(transactions) {
    const connector = await this.getConnector();
    return connector.estimateRaw(transactions);
  }
  async estimateBatchRaw(transactions) {
    const connector = await this.getConnector();
    return connector.estimateBatchRaw(transactions);
  }
  async sendBatchRaw(transactions) {
    const connector = await this.getConnector();
    return connector.sendBatchRaw(transactions);
  }
  async executeBatchRaw(transactions) {
    const connector = await this.getConnector();
    return connector.executeBatchRaw(transactions);
  }
  async deploy() {
    const connector = await this.getConnector();
    return connector.deploy();
  }
  async deployIfNeeded() {
    const connector = await this.getConnector();
    return connector.deployIfNeeded();
  }
  async isDeployed() {
    const connector = await this.getConnector();
    return connector.isDeployed();
  }
  async createSessionKey(keyAddress, permissions) {
    const connector = await this.getConnector();
    return connector.grantPermissions(keyAddress, permissions);
  }
  async revokeSessionKey(keyAddress) {
    const connector = await this.getConnector();
    return connector.revokePermissions(keyAddress);
  }
  async addAdmin(adminAddress) {
    const connector = await this.getConnector();
    return connector.addAdmin(adminAddress);
  }
  async removeAdmin(adminAddress) {
    const connector = await this.getConnector();
    return connector.removeAdmin(adminAddress);
  }
  async getAllActiveSigners() {
    const connector = await this.getConnector();
    return connector.getAllActiveSigners();
  }
  async getAccountContract() {
    const connector = await this.getConnector();
    return connector.getAccountContract();
  }
  async getFactoryContract() {
    const connector = await this.getConnector();
    return connector.getFactoryContract();
  }
  autoConnect(params) {
    return this.connect(params);
  }
  async connectApp(uri) {
    var _a;
    if (!this.enableConnectApp) {
      throw new Error("enableConnectApp is set to false in this wallet config");
    }
    (_a = this.wcWallet) == null ? void 0 : _a.connectApp(uri);
  }
  async approveSession() {
    await this.wcWallet.approveSession(this);
    this.emit("message", {
      type: "session_approved"
    });
  }
  rejectSession() {
    return this.wcWallet.rejectSession();
  }
  approveRequest() {
    return this.wcWallet.approveEIP155Request(this);
  }
  rejectRequest() {
    return this.wcWallet.rejectEIP155Request();
  }
  getActiveSessions() {
    if (!this.wcWallet) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    return this.wcWallet.getActiveSessions();
  }
  disconnectSession() {
    var _a;
    return (_a = this.wcWallet) == null ? void 0 : _a.disconnectSession();
  }
  isWCReceiverEnabled() {
    return this.enableConnectApp;
  }
  setupWalletConnectEventsListeners() {
    if (!this.wcWallet) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    this.wcWallet.on("session_proposal", (proposal) => {
      this.emit("message", {
        type: "session_proposal",
        data: proposal
      });
    });
    this.wcWallet.on("session_delete", () => {
      this.emit("message", {
        type: "session_delete"
      });
    });
    this.wcWallet.on("switch_chain", (request) => {
      const chainId = request.params[0].chainId;
      this.emit("message", {
        type: "switch_chain",
        data: {
          chainId
        }
      });
      this.wcWallet.disconnectSession();
    });
    this.wcWallet.on("session_request", (request) => {
      this.emit("message", {
        type: "session_request",
        data: request
      });
    });
  }
};
_defineProperty(SmartWallet, "meta", {
  name: "Smart Wallet",
  iconURL: "ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg"
});
_defineProperty(SmartWallet, "id", walletIds.smartWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/okx/dist/thirdweb-dev-wallets-evm-wallets-okx.browser.esm.js
init_shim();
init_lib3();
var OKXWallet = class extends AbstractClientWallet {
  get walletName() {
    return "OKX";
  }
  constructor(options) {
    super(OKXWallet.id, options);
    this.isInjected = !!getInjectedOKXProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          OKXConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-okx.browser.esm-BYUL3FZU.js");
        this.OKXConnector = new OKXConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.OKXConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-GFIRAGYJ.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
  async switchAccount() {
    if (!this.OKXConnector) {
      throw new Error("Can not switch Account");
    }
    await this.OKXConnector.switchAccount();
  }
};
_defineProperty(OKXWallet, "id", walletIds.okx);

// node_modules/@thirdweb-dev/wallets/dist/getInjectedCoinbaseProvider-980f40a9.browser.esm.js
init_shim();
function getInjectedCoinbaseProvider() {
  var _a;
  function getReady(ethereum) {
    const isCoinbaseWallet = !!(ethereum == null ? void 0 : ethereum.isCoinbaseWallet);
    if (isCoinbaseWallet) {
      return ethereum;
    }
    if (ethereum && "overrideIsMetaMask" in ethereum) {
      if ("providerMap" in ethereum) {
        if (ethereum.providerMap instanceof Map) {
          if (ethereum.providerMap.has("CoinbaseWallet")) {
            return ethereum;
          }
        }
      }
    }
  }
  if (assertWindowEthereum(globalThis.window)) {
    if ((_a = globalThis.window.ethereum) == null ? void 0 : _a.providers) {
      return globalThis.window.ethereum.providers.find(getReady);
    }
    return getReady(globalThis.window.ethereum);
  }
}

// node_modules/@thirdweb-dev/wallets/evm/wallets/paper-wallet/dist/thirdweb-dev-wallets-evm-wallets-paper-wallet.browser.esm.js
init_shim();
init_lib3();
var PaperWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Paper Wallet";
  }
  constructor(options) {
    var _a, _b;
    super(PaperWallet.id, {
      ...options
    });
    try {
      this.chain = {
        ...options.chain,
        rpc: getValidChainRPCs(options.chain, options.clientId)
      };
    } catch {
      this.chain = options.chain;
    }
    if (options.paperClientId && options.paperClientId === "uninitialized") {
      this.paperClientId = "00000000-0000-0000-0000-000000000000";
      return;
    }
    if (options.advancedOptions && ((_a = options.advancedOptions) == null ? void 0 : _a.recoveryShareManagement) === "USER_MANAGED") {
      if (options.paperClientId && !this.isClientIdLegacyPaper(options.paperClientId) || !options.paperClientId && options.clientId && !this.isClientIdLegacyPaper(options.clientId)) {
        throw new Error('RecoveryShareManagement option "USER_MANAGED" is not supported with thirdweb client ID');
      }
    }
    if (!options.clientId && !options.paperClientId) {
      throw new Error("clientId or paperClientId is required");
    }
    if (options.paperClientId && !this.isClientIdLegacyPaper(options.paperClientId)) {
      throw new Error("paperClientId must be a legacy paper client ID");
    }
    if (options.clientId && this.isClientIdLegacyPaper(options.clientId)) {
      throw new Error("clientId must be a thirdweb client ID");
    }
    this.paperClientId = (_b = options.paperClientId) != null ? _b : options.clientId;
    this.onAuthSuccess = options.onAuthSuccess;
  }
  isClientIdLegacyPaper(clientId) {
    return clientId.indexOf("-") > 0 && clientId.length === 36;
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      const {
        PaperWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-paper.browser.esm-AZCNMTZD.js");
      this.connector = new PaperWalletConnector({
        clientId: this.paperClientId,
        chain: this.chain,
        chains: this.chains,
        onAuthSuccess: this.onAuthSuccess,
        advancedOptions: {
          recoveryShareManagement: (_b = (_a = this.options) == null ? void 0 : _a.advancedOptions) == null ? void 0 : _b.recoveryShareManagement
        },
        styles: (_c = this.options) == null ? void 0 : _c.styles
      });
    }
    return this.connector;
  }
  getConnectParams() {
    const connectParams = super.getConnectParams();
    if (!connectParams) {
      return void 0;
    }
    if (typeof connectParams.googleLogin === "object") {
      return {
        ...connectParams,
        googleLogin: true
      };
    }
    return connectParams;
  }
  async getEmail() {
    const connector = await this.getConnector();
    return connector.getEmail();
  }
  async getPaperSDK() {
    const connector = await this.getConnector();
    return connector.getPaperSDK();
  }
};
_defineProperty(PaperWallet, "id", walletIds.paper);
_defineProperty(PaperWallet, "meta", {
  name: "Paper Wallet",
  iconURL: "ipfs://QmNrLXtPoFrh4yjZbXui39zUMozS1oetpgU8dvZhFAxfRa/paper-logo-icon.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/blocto/dist/thirdweb-dev-wallets-evm-wallets-blocto.browser.esm.js
init_shim();
init_lib3();
var BloctoWallet = class extends AbstractClientWallet {
  constructor(options) {
    if ((options == null ? void 0 : options.chain) && options.clientId) {
      options.chain = updateChainRPCs(options.chain, options.clientId);
    }
    super(BloctoWallet.id, options);
    _defineProperty(this, "name", "Blocto");
  }
  async initConnector() {
    var _a, _b, _c;
    const {
      BloctoConnector
    } = await import("./thirdweb-dev-wallets-evm-connectors-blocto.browser.esm-USXM2WRS.js");
    const bloctoConnector = new BloctoConnector({
      chains: this.chains,
      options: {
        appId: (_a = this.options) == null ? void 0 : _a.appId,
        chainId: (_c = (_b = this.options) == null ? void 0 : _b.chain) == null ? void 0 : _c.chainId
      }
    });
    this.connector = new WagmiAdapter(bloctoConnector);
    return this.connector;
  }
  async getConnector() {
    if (!this.connector) {
      return await this.initConnector();
    }
    return Promise.resolve(this.connector);
  }
};
_defineProperty(BloctoWallet, "id", walletIds.blocto);
_defineProperty(BloctoWallet, "meta", {
  name: "Blocto",
  iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzIyMzNfMjM4NykiPgo8cmVjdCB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHJ4PSIxMiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZD0iTTMyLjkwMjggMTguMzA2M0MyOC4zOTExIDE4LjMwNjMgMjMuOTg3MyAyMC4wNDU5IDIwLjY5NTIgMjMuMTMxOUMxNy4wODQzIDI2LjUxNzYgMTQuNzk5MiAzMS41MTc3IDEzLjQ4OTMgMzYuMjIxMkMxMi42MzE0IDM5LjI5OTIgMTIuMjAxNiA0Mi40OTE1IDEyLjIwMTYgNDUuNjg1M0MxMi4yMDE2IDQ2LjY1MTEgMTIuMjQxMiA0Ny42MDg5IDEyLjMxNzQgNDguNTU1NkMxMi40MTA5IDQ5LjcwNjkgMTMuNTMyMSA1MC41MDQ2IDE0LjY0ODUgNTAuMjAzM0MxNS42MjIyIDQ5Ljk0MTYgMTYuNjQ2NiA0OS44MDA1IDE3LjcwMjggNDkuODAwNUMxOS44NzIyIDQ5LjgwMDUgMjEuOTA1MiA1MC4zOTA0IDIzLjY0OCA1MS40MjEyQzIzLjY5MDggNTEuNDQ2NiAyMy43MzIgNTEuNDcxOSAyMy43NzQ4IDUxLjQ5NTdDMjYuNjA3MSA1My4xODQ2IDI5Ljk0ODQgNTQuMTEyMyAzMy41MTE3IDUzLjk5MzRDNDIuODA2MiA1My42ODU3IDUwLjM5OSA0Ni4xMjMgNTAuNzQxNiAzNi44MzAxQzUxLjExNTggMjYuNjYzNSA0Mi45ODY5IDE4LjMwNDcgMzIuOTA0NCAxOC4zMDQ3TDMyLjkwMjggMTguMzA2M1pNMzIuOTAyOCA0NC4zMTJDMjguMzk3NSA0NC4zMTIgMjQuNzQ1NCA0MC42NTk5IDI0Ljc0NTQgMzYuMTU2MkMyNC43NDU0IDMxLjY1MjUgMjguMzk3NSAyNy45OTg3IDMyLjkwMjggMjcuOTk4N0MzNy40MDgxIDI3Ljk5ODcgNDEuMDYwMiAzMS42NTA5IDQxLjA2MDIgMzYuMTU2MkM0MS4wNjAyIDQwLjY2MTQgMzcuNDA4MSA0NC4zMTIgMzIuOTAyOCA0NC4zMTJaIiBmaWxsPSIjMTRBQUZGIi8+CjxwYXRoIGQ9Ik0yNS41NjM2IDEyLjY4MjZDMjUuNTYzNiAxNS4wMzQ0IDI0LjMzMTUgMTcuMjE2NCAyMi4zMDggMTguNDE1M0MyMS4wMzc3IDE5LjE2ODYgMTkuODQ2OCAyMC4wNTgyIDE4Ljc2ODQgMjEuMDcxNUMxNi4zNzU1IDIzLjMxMzkgMTQuNTg5OCAyNi4wNjUzIDEzLjI2NzMgMjguNzkyOUMxMy4wMDcyIDI5LjMzMDQgMTIuMiAyOS4xNDAyIDEyLjIgMjguNTQyM1YxMi42ODI2QzEyLjIgOC45OTI0MiAxNS4xOTI0IDYgMTguODgyNiA2QzIyLjU3MjggNiAyNS41NjUyIDguOTkyNDIgMjUuNTY1MiAxMi42ODI2SDI1LjU2MzZaIiBmaWxsPSIjMDA3NUZGIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDBfMjIzM18yMzg3Ij4KPHJlY3Qgd2lkdGg9IjYwIiBoZWlnaHQ9IjYwIiBmaWxsPSJ3aGl0ZSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
  urls: {
    android: "https://play.google.com/store/apps/details?id=com.portto.blocto",
    ios: "https://apps.apple.com/app/blocto/id1481181682"
  }
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/coinbase-wallet/dist/thirdweb-dev-wallets-evm-wallets-coinbase-wallet.browser.esm.js
init_shim();
var import_buffer = __toESM(require_buffer());
init_lib3();
{
  window.Buffer = import_buffer.Buffer;
}
var CoinbaseWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Coinbase Wallet";
  }
  constructor(options) {
    super(CoinbaseWallet.id, options);
    this.headlessMode = (options == null ? void 0 : options.headlessMode) || false;
    this.theme = (options == null ? void 0 : options.theme) || this.dappMetadata.isDarkMode === false ? "light" : "dark";
  }
  async getConnector() {
    if (!this.connector) {
      const {
        CoinbaseWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-coinbase-wallet.browser.esm-5UI5ENQ3.js");
      const cbConnector = new CoinbaseWalletConnector({
        chains: this.chains,
        options: {
          appName: this.dappMetadata.name,
          reloadOnDisconnect: false,
          darkMode: this.theme === "dark",
          headlessMode: this.headlessMode
        }
      });
      cbConnector.on("connect", () => {
      });
      this.coinbaseConnector = cbConnector;
      this.connector = new WagmiAdapter(cbConnector);
    }
    return this.connector;
  }
  async getQrUrl() {
    await this.getConnector();
    if (!this.coinbaseConnector) {
      throw new Error("Coinbase connector not initialized");
    }
    return this.coinbaseConnector.getQrUrl();
  }
};
_defineProperty(CoinbaseWallet, "meta", {
  iconURL: "ipfs://QmcJBHopbwfJcLqJpX2xEufSS84aLbF7bHavYhaXUcrLaH/coinbase.svg",
  name: "Coinbase Wallet",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad",
    android: "https://play.google.com/store/apps/details?id=org.toshi",
    ios: "https://apps.apple.com/us/app/coinbase-wallet-nfts-crypto/id1278383455"
  }
});
_defineProperty(CoinbaseWallet, "id", walletIds.coinbase);

// node_modules/@thirdweb-dev/wallets/evm/wallets/embedded-wallet/dist/thirdweb-dev-wallets-evm-wallets-embedded-wallet.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/wallets/evm/connectors/embedded-wallet/dist/thirdweb-dev-wallets-evm-connectors-embedded-wallet.browser.esm.js
init_shim();
init_lib3();

// node_modules/@thirdweb-dev/wallets/dist/embedded-wallet-89e555d2.browser.esm.js
init_shim();
init_lib3();
var import_utils4 = __toESM(require_utils());
var EMBEDDED_WALLET_PATH = "/sdk/2022-08-12/embedded-wallet";
var GET_IFRAME_BASE_URL = () => `${i().replace("withpaper.com", "ews.thirdweb.com")}`;
var WALLET_USER_ID_LOCAL_STORAGE_NAME = (clientId) => `thirdwebEwsWalletUserId-${clientId}`;
var AUTH_TOKEN_LOCAL_STORAGE_PREFIX = "walletToken";
var AUTH_TOKEN_LOCAL_STORAGE_NAME = (clientId) => {
  return `${AUTH_TOKEN_LOCAL_STORAGE_PREFIX}-${clientId}`;
};
var DEVICE_SHARE_LOCAL_STORAGE_PREFIX = "a";
var DEVICE_SHARE_LOCAL_STORAGE_NAME = (clientId, userId) => `${DEVICE_SHARE_LOCAL_STORAGE_PREFIX}-${clientId}-${userId}`;
var UserStatus = function(UserStatus2) {
  UserStatus2["LOGGED_OUT"] = "Logged Out";
  UserStatus2["LOGGED_IN_WALLET_INITIALIZED"] = "Logged In, Wallet Initialized";
  return UserStatus2;
}({});
var UserWalletStatus = function(UserWalletStatus2) {
  UserWalletStatus2["LOGGED_OUT"] = "Logged Out";
  UserWalletStatus2["LOGGED_IN_WALLET_UNINITIALIZED"] = "Logged In, Wallet Uninitialized";
  UserWalletStatus2["LOGGED_IN_NEW_DEVICE"] = "Logged In, New Device";
  UserWalletStatus2["LOGGED_IN_WALLET_INITIALIZED"] = "Logged In, Wallet Initialized";
  return UserWalletStatus2;
}({});
var data = /* @__PURE__ */ new Map();
var LocalStorage = class {
  constructor(_ref) {
    let {
      clientId
    } = _ref;
    this.isSupported = !!window.localStorage;
    this.clientId = clientId;
  }
  async getItem(key) {
    var _a;
    if (this.isSupported) {
      return window.localStorage.getItem(key);
    } else {
      return (_a = data.get(key)) != null ? _a : null;
    }
  }
  async setItem(key, value) {
    if (this.isSupported) {
      return window.localStorage.setItem(key, value);
    } else {
      data.set(key, value);
    }
  }
  async removeItem(key) {
    const item = await this.getItem(key);
    if (this.isSupported && item) {
      window.localStorage.removeItem(key);
      return true;
    }
    return false;
  }
  async saveAuthCookie(cookie) {
    await this.setItem(AUTH_TOKEN_LOCAL_STORAGE_NAME(this.clientId), cookie);
  }
  async getAuthCookie() {
    return this.getItem(AUTH_TOKEN_LOCAL_STORAGE_NAME(this.clientId));
  }
  async removeAuthCookie() {
    return this.removeItem(AUTH_TOKEN_LOCAL_STORAGE_NAME(this.clientId));
  }
  async saveDeviceShare(share, userId) {
    await this.saveWalletUserId(userId);
    await this.setItem(DEVICE_SHARE_LOCAL_STORAGE_NAME(this.clientId, userId), share);
  }
  async getDeviceShare() {
    const userId = await this.getWalletUserId();
    if (userId) {
      return this.getItem(DEVICE_SHARE_LOCAL_STORAGE_NAME(this.clientId, userId));
    }
    return null;
  }
  async removeDeviceShare() {
    const userId = await this.getWalletUserId();
    if (userId) {
      return this.removeItem(DEVICE_SHARE_LOCAL_STORAGE_NAME(this.clientId, userId));
    }
    return false;
  }
  async getWalletUserId() {
    return this.getItem(WALLET_USER_ID_LOCAL_STORAGE_NAME(this.clientId));
  }
  async saveWalletUserId(userId) {
    await this.setItem(WALLET_USER_ID_LOCAL_STORAGE_NAME(this.clientId), userId);
  }
  async removeWalletUserId() {
    return this.removeItem(WALLET_USER_ID_LOCAL_STORAGE_NAME(this.clientId));
  }
};
function sleep(seconds) {
  return new Promise((resolve) => {
    setTimeout(resolve, seconds * 1e3);
  });
}
var iframeBaseStyle = {
  height: "100%",
  width: "100%",
  border: "none",
  backgroundColor: "transparent",
  colorScheme: "light",
  position: "fixed",
  top: "0px",
  right: "0px",
  zIndex: "2147483646",
  display: "none"
};
var isIframeLoaded = /* @__PURE__ */ new Map();
var IframeCommunicator = class {
  constructor(_ref) {
    let {
      link,
      iframeId,
      container = document.body,
      iframeStyles,
      onIframeInitialize
    } = _ref;
    _defineProperty(this, "POLLING_INTERVAL_SECONDS", 1.4);
    this.iframeBaseUrl = GET_IFRAME_BASE_URL();
    let iframe = document.getElementById(iframeId);
    const hrefLink = new URL(link);
    const sdkVersion = "2.0.10";
    hrefLink.searchParams.set("sdkVersion", sdkVersion);
    if (!iframe || iframe.src !== hrefLink.href) {
      if (!iframe) {
        iframe = document.createElement("iframe");
        const mergedIframeStyles = {
          ...iframeBaseStyle,
          ...iframeStyles
        };
        Object.assign(iframe.style, mergedIframeStyles);
        iframe.setAttribute("id", iframeId);
        iframe.setAttribute("fetchpriority", "high");
        container.appendChild(iframe);
      }
      iframe.src = hrefLink.href;
      iframe.setAttribute("data-version", sdkVersion);
      const onIframeLoaded = (event) => {
        if (event.data.eventType === "ewsIframeLoaded") {
          window.removeEventListener("message", onIframeLoaded);
          if (!iframe) {
            console.warn("thirdweb Iframe not found");
            return;
          }
          this.onIframeLoadHandler(iframe, onIframeInitialize)();
        }
      };
      window.addEventListener("message", onIframeLoaded);
    }
    this.iframe = iframe;
  }
  async onIframeLoadedInitVariables() {
    return {};
  }
  onIframeLoadHandler(iframe, onIframeInitialize) {
    return async () => {
      const promise = new Promise(async (res, rej) => {
        var _a;
        const channel = new MessageChannel();
        channel.port1.onmessage = (event) => {
          const {
            data: data2
          } = event;
          channel.port1.close();
          if (!data2.success) {
            return rej(new Error(data2.error));
          }
          isIframeLoaded.set(iframe.src, true);
          if (onIframeInitialize) {
            onIframeInitialize();
          }
          return res(true);
        };
        const INIT_IFRAME_EVENT = "initIframe";
        (_a = iframe == null ? void 0 : iframe.contentWindow) == null ? void 0 : _a.postMessage(
          {
            eventType: INIT_IFRAME_EVENT,
            data: await this.onIframeLoadedInitVariables()
          },
          this.iframeBaseUrl,
          [channel.port2]
        );
      });
      await promise;
    };
  }
  async call(_ref2) {
    let {
      procedureName,
      params,
      showIframe = false
    } = _ref2;
    while (!isIframeLoaded.get(this.iframe.src)) {
      await sleep(this.POLLING_INTERVAL_SECONDS);
    }
    if (showIframe) {
      this.iframe.style.display = "block";
      await sleep(5e-3);
    }
    const promise = new Promise((res, rej) => {
      var _a;
      const channel = new MessageChannel();
      channel.port1.onmessage = async (event) => {
        const {
          data: data2
        } = event;
        channel.port1.close();
        if (showIframe) {
          await sleep(0.1);
          this.iframe.style.display = "none";
        }
        if (!data2.success) {
          rej(new Error(data2.error));
        } else {
          res(data2.data);
        }
      };
      (_a = this.iframe.contentWindow) == null ? void 0 : _a.postMessage({
        eventType: procedureName,
        data: params
      }, this.iframeBaseUrl, [channel.port2]);
    });
    return promise;
  }
  destroy() {
    isIframeLoaded.delete(this.iframe.src);
  }
};
var EmbeddedWalletIframeCommunicator = class extends IframeCommunicator {
  constructor(_ref) {
    let {
      clientId,
      customizationOptions
    } = _ref;
    super({
      iframeId: EMBEDDED_WALLET_IFRAME_ID,
      link: createEmbeddedWalletIframeLink({
        clientId,
        path: EMBEDDED_WALLET_PATH,
        queryParams: customizationOptions
      }).href,
      container: document.body
    });
    this.clientId = clientId;
  }
  async onIframeLoadedInitVariables() {
    const localStorage2 = new LocalStorage({
      clientId: this.clientId
    });
    return {
      authCookie: await localStorage2.getAuthCookie(),
      deviceShareStored: await localStorage2.getDeviceShare(),
      walletUserId: await localStorage2.getWalletUserId(),
      clientId: this.clientId
    };
  }
};
function createEmbeddedWalletIframeLink(_ref2) {
  var _a;
  let {
    clientId,
    path,
    queryParams
  } = _ref2;
  const embeddedWalletUrl = new URL(`${path}`, GET_IFRAME_BASE_URL());
  if (queryParams) {
    for (const queryKey of Object.keys(queryParams)) {
      embeddedWalletUrl.searchParams.set(queryKey, ((_a = queryParams[queryKey]) == null ? void 0 : _a.toString()) || "");
    }
  }
  embeddedWalletUrl.searchParams.set("clientId", clientId);
  return embeddedWalletUrl;
}
var EMBEDDED_WALLET_IFRAME_ID = "thirdweb-embedded-wallet-iframe";
var AbstractLogin = class {
  constructor(_ref) {
    let {
      querier,
      preLogin,
      postLogin,
      clientId
    } = _ref;
    this.LoginQuerier = querier;
    this.preLogin = preLogin;
    this.postLogin = postLogin;
    this.clientId = clientId;
  }
  async sendEmailLoginOtp(_ref2) {
    let {
      email
    } = _ref2;
    await this.preLogin();
    const result = await this.LoginQuerier.call({
      procedureName: "sendThirdwebEmailLoginOtp",
      params: {
        email
      }
    });
    return result;
  }
};
var BaseLogin = class extends AbstractLogin {
  constructor() {
    super(...arguments);
    _defineProperty(this, "closeWindow", (_ref) => {
      let {
        isWindowOpenedByFn,
        win,
        closeOpenedWindow
      } = _ref;
      if (isWindowOpenedByFn) {
        win == null ? void 0 : win.close();
      } else {
        if (win && closeOpenedWindow) {
          closeOpenedWindow(win);
        } else if (win) {
          win.close();
        }
      }
    });
  }
  async getGoogleLoginUrl() {
    const result = await this.LoginQuerier.call({
      procedureName: "getHeadlessGoogleLoginLink",
      params: void 0
    });
    return result;
  }
  async loginWithModal() {
    await this.preLogin();
    const result = await this.LoginQuerier.call({
      procedureName: "loginWithThirdwebModal",
      params: void 0,
      showIframe: true
    });
    return this.postLogin(result);
  }
  async loginWithEmailOtp(_ref2) {
    let {
      email
    } = _ref2;
    await this.preLogin();
    const result = await this.LoginQuerier.call({
      procedureName: "loginWithThirdwebModal",
      params: {
        email
      },
      showIframe: true
    });
    return this.postLogin(result);
  }
  async loginWithGoogle(args) {
    await this.preLogin();
    let win = args == null ? void 0 : args.openedWindow;
    let isWindowOpenedByFn = false;
    if (!win) {
      win = window.open("", "Login", "width=350, height=500");
      isWindowOpenedByFn = true;
    }
    if (!win) {
      throw new Error("Something went wrong opening pop-up");
    }
    await this.preLogin();
    const {
      loginLink
    } = await this.getGoogleLoginUrl();
    win.location.href = loginLink;
    const result = await new Promise((resolve, reject) => {
      const pollTimer = window.setInterval(async () => {
        if (!win) {
          return;
        }
        if (win.closed) {
          clearInterval(pollTimer);
          window.removeEventListener("message", messageListener);
          reject(new Error("User closed login window"));
        }
      }, 1e3);
      const messageListener = async (event) => {
        if (event.origin !== GET_IFRAME_BASE_URL()) {
          return;
        }
        if (typeof event.data !== "object") {
          reject(new Error("Invalid event data"));
          return;
        }
        switch (event.data.eventType) {
          case "userLoginSuccess": {
            window.removeEventListener("message", messageListener);
            clearInterval(pollTimer);
            this.closeWindow({
              isWindowOpenedByFn,
              win,
              closeOpenedWindow: args == null ? void 0 : args.closeOpenedWindow
            });
            if (event.data.authResult) {
              resolve(event.data.authResult);
            }
            break;
          }
          case "userLoginFailed": {
            window.removeEventListener("message", messageListener);
            clearInterval(pollTimer);
            this.closeWindow({
              isWindowOpenedByFn,
              win,
              closeOpenedWindow: args == null ? void 0 : args.closeOpenedWindow
            });
            reject(new Error(event.data.error));
            break;
          }
          case "injectDeveloperClientId": {
            win == null ? void 0 : win.postMessage({
              eventType: "injectDeveloperClientIdResult",
              developerClientId: this.clientId
            }, GET_IFRAME_BASE_URL());
            break;
          }
        }
      };
      window.addEventListener("message", messageListener);
    });
    return this.postLogin({
      storedToken: {
        ...result.storedToken,
        shouldStoreCookieString: true
      },
      walletDetails: {
        ...result.walletDetails,
        isIframeStorageEnabled: false
      }
    });
  }
  async verifyEmailLoginOtp(_ref3) {
    let {
      email,
      otp
    } = _ref3;
    const result = await this.LoginQuerier.call({
      procedureName: "verifyThirdwebEmailLoginOtp",
      params: {
        email,
        otp
      }
    });
    return this.postLogin(result);
  }
};
var Auth = class {
  constructor(_ref) {
    let {
      clientId,
      querier,
      onAuthSuccess
    } = _ref;
    this.clientId = clientId;
    this.AuthQuerier = querier;
    this.localStorage = new LocalStorage({
      clientId
    });
    this.onAuthSuccess = onAuthSuccess;
    this.BaseLogin = new BaseLogin({
      postLogin: async (result) => {
        return this.postLogin(result);
      },
      preLogin: async () => {
        await this.preLogin();
      },
      querier,
      clientId
    });
  }
  async preLogin() {
    await this.logout();
  }
  async postLogin(_ref2) {
    let {
      storedToken,
      walletDetails
    } = _ref2;
    if (storedToken.shouldStoreCookieString) {
      await this.localStorage.saveAuthCookie(storedToken.cookieString);
    }
    const initializedUser = await this.onAuthSuccess({
      storedToken,
      walletDetails
    });
    return initializedUser;
  }
  async loginWithModal() {
    await this.preLogin();
    return this.BaseLogin.loginWithModal();
  }
  async loginWithEmailOtp(args) {
    return this.BaseLogin.loginWithEmailOtp(args);
  }
  async loginWithGoogle(args) {
    return this.BaseLogin.loginWithGoogle(args);
  }
  async sendEmailLoginOtp(_ref3) {
    let {
      email
    } = _ref3;
    return this.BaseLogin.sendEmailLoginOtp({
      email
    });
  }
  async verifyEmailLoginOtp(args) {
    return this.BaseLogin.verifyEmailLoginOtp(args);
  }
  async logout() {
    const {
      success
    } = await this.AuthQuerier.call({
      procedureName: "logout",
      params: void 0
    });
    const isRemoveAuthCookie = await this.localStorage.removeAuthCookie();
    const isRemoveUserId = await this.localStorage.removeWalletUserId();
    return {
      success: success || isRemoveAuthCookie || isRemoveUserId
    };
  }
};
var EthersSigner = class extends Signer {
  constructor(_ref) {
    var _a;
    let {
      provider,
      clientId,
      querier
    } = _ref;
    super();
    _defineProperty(this, "DEFAULT_ETHEREUM_CHAIN_ID", 5);
    this.clientId = clientId;
    this.querier = querier;
    this.endpoint = (_a = provider.connection) == null ? void 0 : _a.url;
    (0, import_utils4.defineReadOnly)(this, "provider", provider);
  }
  async getAddress() {
    const {
      address
    } = await this.querier.call({
      procedureName: "getAddress",
      params: void 0
    });
    return address;
  }
  async signMessage(message) {
    var _a, _b, _c;
    const {
      signedMessage
    } = await this.querier.call({
      procedureName: "signMessage",
      params: {
        message,
        chainId: (_c = (_b = await ((_a = this.provider) == null ? void 0 : _a.getNetwork())) == null ? void 0 : _b.chainId) != null ? _c : this.DEFAULT_ETHEREUM_CHAIN_ID,
        rpcEndpoint: this.endpoint
      }
    });
    return signedMessage;
  }
  async signTransaction(transaction) {
    var _a, _b, _c;
    const {
      signedTransaction
    } = await this.querier.call({
      procedureName: "signTransaction",
      params: {
        transaction,
        chainId: (_c = (_b = await ((_a = this.provider) == null ? void 0 : _a.getNetwork())) == null ? void 0 : _b.chainId) != null ? _c : this.DEFAULT_ETHEREUM_CHAIN_ID,
        rpcEndpoint: this.endpoint
      }
    });
    return signedTransaction;
  }
  async _signTypedData(domain, types, message) {
    var _a, _b, _c;
    const {
      signedTypedData
    } = await this.querier.call({
      procedureName: "signTypedDataV4",
      params: {
        domain,
        types,
        message,
        chainId: (_c = (_b = await ((_a = this.provider) == null ? void 0 : _a.getNetwork())) == null ? void 0 : _b.chainId) != null ? _c : this.DEFAULT_ETHEREUM_CHAIN_ID,
        rpcEndpoint: this.endpoint
      }
    });
    return signedTypedData;
  }
  connect(provider) {
    return new EthersSigner({
      clientId: this.clientId,
      provider,
      querier: this.querier
    });
  }
};
var EmbeddedWallet = class {
  constructor(_ref) {
    let {
      clientId,
      chain,
      querier
    } = _ref;
    this.clientId = clientId;
    this.chain = chain;
    this.walletManagerQuerier = querier;
    this.localStorage = new LocalStorage({
      clientId
    });
  }
  async postWalletSetUp(_ref2) {
    let {
      deviceShareStored,
      walletAddress,
      isIframeStorageEnabled,
      walletUserId
    } = _ref2;
    if (!isIframeStorageEnabled) {
      await this.localStorage.saveDeviceShare(deviceShareStored, walletUserId);
    }
    return {
      walletAddress
    };
  }
  async getUserWalletStatus() {
    const userStatus = await this.walletManagerQuerier.call({
      procedureName: "getUserStatus",
      params: void 0
    });
    if (userStatus.status === UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED) {
      return {
        status: UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,
        user: {
          ...userStatus.user,
          wallet: this
        }
      };
    }
    return userStatus;
  }
  async setChain(_ref3) {
    let {
      chain
    } = _ref3;
    this.chain = chain;
  }
  async getEthersJsSigner(network) {
    var _a;
    const signer = new EthersSigner({
      clientId: this.clientId,
      provider: getDefaultProvider((_a = network == null ? void 0 : network.rpcEndpoint) != null ? _a : e[this.chain]),
      querier: this.walletManagerQuerier
    });
    return signer;
  }
};
var EmbeddedWalletSdk = class {
  isClientIdLegacyPaper(clientId) {
    if (clientId.indexOf("-") > 0 && clientId.length === 36) {
      return true;
    } else {
      return false;
    }
  }
  constructor(_ref) {
    let {
      clientId,
      chain,
      styles
    } = _ref;
    if (this.isClientIdLegacyPaper(clientId)) {
      throw new Error("You are using a legacy clientId. Please use the clientId found on the thirdweb dashboard settings page");
    }
    this.clientId = clientId;
    this.querier = new EmbeddedWalletIframeCommunicator({
      clientId,
      customizationOptions: styles
    });
    this.wallet = new EmbeddedWallet({
      clientId,
      chain,
      querier: this.querier
    });
    this.auth = new Auth({
      clientId,
      querier: this.querier,
      onAuthSuccess: async (authResult) => {
        await this.wallet.postWalletSetUp({
          ...authResult.walletDetails,
          walletUserId: authResult.storedToken.authDetails.userWalletId
        });
        await this.querier.call({
          procedureName: "initIframe",
          params: {
            deviceShareStored: authResult.walletDetails.deviceShareStored,
            clientId: this.clientId,
            walletUserId: authResult.storedToken.authDetails.userWalletId,
            authCookie: authResult.storedToken.cookieString
          }
        });
        return {
          user: {
            status: UserStatus.LOGGED_IN_WALLET_INITIALIZED,
            authDetails: authResult.storedToken.authDetails,
            wallet: this.wallet,
            walletAddress: authResult.walletDetails.walletAddress
          }
        };
      }
    });
  }
  async getUser() {
    const userStatus = await this.wallet.getUserWalletStatus();
    switch (userStatus.status) {
      case UserWalletStatus.LOGGED_IN_NEW_DEVICE:
      case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED:
        await this.auth.logout();
        return this.getUser();
      case UserWalletStatus.LOGGED_OUT:
        return {
          status: UserStatus.LOGGED_OUT
        };
      case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED:
        return {
          status: UserStatus.LOGGED_IN_WALLET_INITIALIZED,
          ...userStatus.user
        };
    }
  }
};

// node_modules/@thirdweb-dev/wallets/evm/connectors/embedded-wallet/dist/thirdweb-dev-wallets-evm-connectors-embedded-wallet.browser.esm.js
var import_utils5 = __toESM(require_utils());
var _embeddedWalletSdk = /* @__PURE__ */ new WeakMap();
var _signer = /* @__PURE__ */ new WeakMap();
var EmbeddedWalletConnector = class extends Connector {
  constructor(options) {
    super();
    _defineProperty(this, "id", walletIds.paper);
    _defineProperty(this, "name", "Embedded Wallet");
    _defineProperty(this, "ready", true);
    _defineProperty(this, "user", null);
    _classPrivateFieldInitSpec(this, _embeddedWalletSdk, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _signer, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "onAccountsChanged", async (accounts) => {
      if (accounts.length === 0) {
        await this.onDisconnect();
      } else {
        this.emit("change", {
          account: utils_exports.getAddress(accounts[0])
        });
      }
    });
    _defineProperty(this, "onChainChanged", (chainId) => {
      const id = normalizeChainId(chainId);
      const unsupported = this.options.chains.findIndex((c2) => c2.chainId === id) === -1;
      this.emit("change", {
        chain: {
          id,
          unsupported
        }
      });
    });
    _defineProperty(this, "onDisconnect", async () => {
      this.emit("disconnect");
    });
    this.options = options;
  }
  getEmbeddedWalletSDK() {
    if (!_classPrivateFieldGet(this, _embeddedWalletSdk)) {
      _classPrivateFieldSet(this, _embeddedWalletSdk, new EmbeddedWalletSdk({
        clientId: this.options.clientId,
        chain: "Ethereum",
        styles: this.options.styles
      }));
    }
    return _classPrivateFieldGet(this, _embeddedWalletSdk);
  }
  async connect(options) {
    const thirdwebSDK = await this.getEmbeddedWalletSDK();
    if (!thirdwebSDK) {
      throw new Error("EmbeddedWallet SDK not initialized");
    }
    const user = await thirdwebSDK.getUser();
    switch (user.status) {
      case UserStatus.LOGGED_OUT: {
        let authResult;
        switch (options == null ? void 0 : options.loginType) {
          case "headless_google_oauth": {
            authResult = await thirdwebSDK.auth.loginWithGoogle({
              closeOpenedWindow: options.closeOpenedWindow,
              openedWindow: options.openedWindow
            });
            break;
          }
          case "headless_email_otp_verification": {
            authResult = await thirdwebSDK.auth.verifyEmailLoginOtp({
              email: options.email,
              otp: options.otp
            });
            break;
          }
          case "ui_email_otp": {
            authResult = await thirdwebSDK.auth.loginWithEmailOtp({
              email: options.email
            });
            break;
          }
          default: {
            authResult = await thirdwebSDK.auth.loginWithModal();
            break;
          }
        }
        this.user = authResult.user;
        break;
      }
      case UserStatus.LOGGED_IN_WALLET_INITIALIZED: {
        if ((options == null ? void 0 : options.loginType) === "headless_google_oauth") {
          if (options.closeOpenedWindow && options.openedWindow) {
            options.closeOpenedWindow(options.openedWindow);
          }
        }
        this.user = user;
        break;
      }
    }
    if (!this.user) {
      throw new Error("Error connecting User");
    }
    if (options == null ? void 0 : options.chainId) {
      this.switchChain(options.chainId);
    }
    this.setupListeners();
    return this.getAddress();
  }
  async disconnect() {
    const paper = await _classPrivateFieldGet(this, _embeddedWalletSdk);
    await (paper == null ? void 0 : paper.auth.logout());
    _classPrivateFieldSet(this, _signer, void 0);
    _classPrivateFieldSet(this, _embeddedWalletSdk, void 0);
    this.user = null;
  }
  async getAddress() {
    const signer = await this.getSigner();
    return signer.getAddress();
  }
  async isConnected() {
    try {
      const addr = await this.getAddress();
      return !!addr;
    } catch (e2) {
      return false;
    }
  }
  async getProvider() {
    const signer = await this.getSigner();
    if (!signer.provider) {
      throw new Error("Provider not found");
    }
    return signer.provider;
  }
  async getSigner() {
    var _a;
    if (_classPrivateFieldGet(this, _signer)) {
      return _classPrivateFieldGet(this, _signer);
    }
    if (!this.user) {
      const embeddedWalletSdk = await this.getEmbeddedWalletSDK();
      const user = await embeddedWalletSdk.getUser();
      switch (user.status) {
        case UserStatus.LOGGED_IN_WALLET_INITIALIZED: {
          this.user = user;
          break;
        }
      }
    }
    const signer = await ((_a = this.user) == null ? void 0 : _a.wallet.getEthersJsSigner({
      rpcEndpoint: this.options.chain.rpc[0] || ""
    }));
    if (!signer) {
      throw new Error("Signer not found");
    }
    _classPrivateFieldSet(this, _signer, signer);
    return signer;
  }
  async isAuthorized() {
    return false;
  }
  async switchChain(chainId) {
    var _a, _b;
    const chain = this.options.chains.find((c2) => c2.chainId === chainId);
    if (!chain) {
      throw new Error("Chain not configured");
    }
    await ((_a = this.user) == null ? void 0 : _a.wallet.setChain({
      chain: "Ethereum"
    }));
    _classPrivateFieldSet(this, _signer, await ((_b = this.user) == null ? void 0 : _b.wallet.getEthersJsSigner({
      rpcEndpoint: chain.rpc[0] || ""
    })));
    this.emit("change", {
      chain: {
        id: chainId,
        unsupported: false
      }
    });
  }
  async setupListeners() {
    const provider = await this.getProvider();
    if (provider.on) {
      provider.on("accountsChanged", this.onAccountsChanged);
      provider.on("chainChanged", this.onChainChanged);
      provider.on("disconnect", this.onDisconnect);
    }
  }
  updateChains(chains) {
    this.options.chains = chains;
  }
  async getEmail() {
    await this.getSigner();
    if (!this.user) {
      throw new Error("No user found, Paper Wallet is not connected");
    }
    return this.user.authDetails.email;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/embedded-wallet/dist/thirdweb-dev-wallets-evm-wallets-embedded-wallet.browser.esm.js
init_lib3();
var import_utils6 = __toESM(require_utils());
var EmbeddedWallet2 = class extends AbstractClientWallet {
  get walletName() {
    return "Embedded Wallet";
  }
  constructor(options) {
    super(EmbeddedWallet2.id, {
      ...options
    });
    try {
      this.chain = {
        ...options.chain,
        rpc: getValidChainRPCs(options.chain, options.clientId)
      };
    } catch {
      this.chain = options.chain;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      this.connector = new EmbeddedWalletConnector({
        clientId: (_b = (_a = this.options) == null ? void 0 : _a.clientId) != null ? _b : "",
        chain: this.chain,
        chains: this.chains,
        styles: (_c = this.options) == null ? void 0 : _c.styles
      });
    }
    return this.connector;
  }
  getConnectParams() {
    const connectParams = super.getConnectParams();
    if (!connectParams) {
      return void 0;
    }
    if (connectParams.loginType === "headless_google_oauth") {
      return {
        loginType: connectParams.loginType,
        chainId: connectParams.chainId
      };
    }
    return connectParams;
  }
  async getEmail() {
    const connector = await this.getConnector();
    return connector.getEmail();
  }
  async getEmbeddedWalletSDK() {
    const connector = await this.getConnector();
    return connector.getEmbeddedWalletSDK();
  }
};
_defineProperty(EmbeddedWallet2, "id", walletIds.embeddedWallet);
_defineProperty(EmbeddedWallet2, "meta", {
  name: "Embedded Wallet",
  iconURL: "ipfs://QmNx2evQa6tcQs9VTd3YaDm31ckfStvgRGKFGELahUmrbV/emailIcon.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/frame/dist/thirdweb-dev-wallets-evm-wallets-frame.browser.esm.js
init_shim();
init_lib3();
var FrameWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Frame Wallet";
  }
  constructor(options) {
    super(FrameWallet.id, options);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        FrameConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-frame.browser.esm-OR2ZBPFP.js");
      this.connector = new WagmiAdapter(new FrameConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(FrameWallet, "id", walletIds.frame);

// node_modules/@thirdweb-dev/wallets/evm/wallets/injected/dist/thirdweb-dev-wallets-evm-wallets-injected.browser.esm.js
init_shim();
init_lib3();
var InjectedWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Injected Wallet";
  }
  constructor(options) {
    super(InjectedWallet.id, options);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        InjectedConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-injected.browser.esm-KBKE3FCZ.js");
      this.connector = new WagmiAdapter(new InjectedConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(InjectedWallet, "id", "injected");

// node_modules/@thirdweb-dev/wallets/evm/wallets/local-wallet/dist/thirdweb-dev-wallets-evm-wallets-local-wallet.browser.esm.js
init_shim();
init_lib3();
var STORAGE_KEY_WALLET_DATA = "localWalletData";
var _storage2 = /* @__PURE__ */ new WeakMap();
var _saveData = /* @__PURE__ */ new WeakSet();
var LocalWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Local Wallet";
  }
  constructor(options) {
    super(LocalWallet.id, options);
    _classPrivateMethodInitSpec(this, _saveData);
    _classPrivateFieldInitSpec(this, _storage2, {
      writable: true,
      value: void 0
    });
    if ((options == null ? void 0 : options.chain) && options.clientId) {
      options.chain = updateChainRPCs(options.chain, options.clientId);
    }
    this.options = options || {};
    _classPrivateFieldSet(this, _storage2, (options == null ? void 0 : options.storage) || createAsyncLocalStorage(walletIds.localWallet));
  }
  async getConnector() {
    if (!this.connector) {
      const {
        LocalWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-local-wallet.browser.esm-I6SOR44C.js");
      if (!this.ethersWallet) {
        throw new Error("wallet is not initialized");
      }
      const defaults = (this.options.chain ? [...defaultChains, this.options.chain] : defaultChains).map((c2) => updateChainRPCs(c2, this.options.clientId));
      this.connector = new LocalWalletConnector({
        chain: this.options.chain || updateChainRPCs(c1, this.options.clientId),
        ethersWallet: this.ethersWallet,
        chains: this.chains || defaults,
        clientId: this.options.clientId,
        secretKey: this.options.secretKey
      });
    }
    return this.connector;
  }
  async loadOrCreate(options) {
    if (await this.getSavedData(options.storage)) {
      await this.load(options);
    } else {
      await this.generate();
      await this.save(options);
    }
  }
  async generate() {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    const random = utils_exports.randomBytes(32);
    this.ethersWallet = new Wallet(random);
    return this.ethersWallet.address;
  }
  async import(options) {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    if ("encryptedJson" in options) {
      this.ethersWallet = await Wallet.fromEncryptedJson(options.encryptedJson, options.password);
      return this.ethersWallet.address;
    }
    if ("privateKey" in options) {
      if (!options.encryption && !isValidPrivateKey(options.privateKey)) {
        throw new Error("invalid private key");
      }
      const privateKey = await getDecryptor(options.encryption)(options.privateKey);
      if (options.encryption && (privateKey === "" || !isValidPrivateKey(privateKey))) {
        throw new Error("invalid password");
      }
      this.ethersWallet = new Wallet(privateKey);
      return this.ethersWallet.address;
    }
    if ("mnemonic" in options) {
      if (!options.encryption && !utils_exports.isValidMnemonic(options.mnemonic)) {
        throw new Error("invalid mnemonic");
      }
      const mnemonic = await getDecryptor(options.encryption)(options.mnemonic);
      if (options.encryption && (mnemonic === "" || !utils_exports.isValidMnemonic(mnemonic))) {
        throw new Error("invalid password");
      }
      this.ethersWallet = Wallet.fromMnemonic(mnemonic);
      return this.ethersWallet.address;
    }
    throw new Error("invalid import strategy");
  }
  async load(options) {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    const walletData = await this.getSavedData(options.storage);
    if (!walletData) {
      throw new Error("No Saved wallet found in storage");
    }
    if (walletData.strategy !== options.strategy) {
      throw new Error(`Saved wallet data is not ${options.strategy}, it is ${walletData.strategy}`);
    }
    if (options.strategy === "encryptedJson") {
      return this.import({
        encryptedJson: walletData.data,
        password: options.password
      });
    }
    if (walletData.isEncrypted && !options.encryption) {
      throw new Error("Saved wallet data is encrypted, but no password is provided");
    }
    if (!walletData.isEncrypted && options.encryption) {
      throw new Error("Saved wallet data is not encrypted, but encryption config is provided");
    }
    if (options.strategy === "privateKey") {
      return this.import({
        privateKey: walletData.data,
        encryption: options.encryption
      });
    }
    if (options.strategy === "mnemonic") {
      return this.import({
        mnemonic: walletData.data,
        encryption: options.encryption
      });
    }
    throw new Error("invalid load strategy");
  }
  async save(options) {
    const wallet = this.ethersWallet;
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      const encryptedData = await wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {
        address: wallet.address,
        data: encryptedData,
        strategy: "encryptedJson",
        isEncrypted: true
      }, options.storage);
    }
    if (options.strategy === "privateKey") {
      const privateKey = await getEncryptor(options.encryption)(wallet.privateKey);
      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {
        address: wallet.address,
        data: privateKey,
        strategy: "privateKey",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
    if (options.strategy === "mnemonic") {
      if (!wallet.mnemonic) {
        throw new Error("mnemonic can not be computed if wallet is created from a private key or generated using generate()");
      }
      const mnemonic = await getEncryptor(options.encryption)(wallet.mnemonic.phrase);
      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {
        address: wallet.address,
        data: mnemonic,
        strategy: "mnemonic",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
  }
  async isSaved() {
    try {
      const data2 = await this.getSavedData();
      const address = await this.getAddress();
      if ((data2 == null ? void 0 : data2.address) === address) {
        return true;
      }
      return false;
    } catch (e2) {
      return false;
    }
  }
  async deleteSaved() {
    await _classPrivateFieldGet(this, _storage2).removeItem(STORAGE_KEY_WALLET_DATA);
  }
  async export(options) {
    const wallet = this.ethersWallet;
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      return wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
    }
    if (options.strategy === "privateKey") {
      return getEncryptor(options.encryption)(wallet.privateKey);
    }
    if (options.strategy === "mnemonic") {
      if (!wallet.mnemonic) {
        throw new Error("mnemonic can not be computed if wallet is created from a private key or generated using generate()");
      }
      return getEncryptor(options.encryption)(wallet.mnemonic.phrase);
    }
    throw new Error("Invalid export strategy");
  }
  async getSavedData(storage) {
    const _storage3 = storage || _classPrivateFieldGet(this, _storage2);
    try {
      const savedDataStr = await _storage3.getItem(STORAGE_KEY_WALLET_DATA);
      if (!savedDataStr) {
        return null;
      }
      const savedData = JSON.parse(savedDataStr);
      if (!savedData) {
        return null;
      }
      return savedData;
    } catch (e2) {
      return null;
    }
  }
  async disconnect() {
    await super.disconnect();
    this.ethersWallet = void 0;
  }
};
async function _saveData2(data2, storage) {
  const _storage3 = storage || _classPrivateFieldGet(this, _storage2);
  await _storage3.setItem(STORAGE_KEY_WALLET_DATA, JSON.stringify(data2));
}
_defineProperty(LocalWallet, "id", walletIds.localWallet);
_defineProperty(LocalWallet, "meta", {
  name: "Local Wallet",
  iconURL: "ipfs://QmbQzSNGvmNYZzem9jZRuYeLe9K2W4pqbdnVUp7Y6edQ8Y/local-wallet.svg"
});
async function defaultEncrypt(message, password) {
  const cryptoJS = (await import("./crypto-js-QZVMDJOW.js")).default;
  return cryptoJS.AES.encrypt(message, password).toString();
}
async function defaultDecrypt(message, password) {
  const cryptoJS = (await import("./crypto-js-QZVMDJOW.js")).default;
  return cryptoJS.AES.decrypt(message, password).toString(cryptoJS.enc.Utf8);
}
function getDecryptor(encryption) {
  const noop = async (msg) => msg;
  return encryption ? (msg) => (encryption.decrypt || defaultDecrypt)(msg, encryption.password) : noop;
}
function getEncryptor(encryption) {
  const noop = async (msg) => msg;
  return encryption ? (msg) => (encryption.encrypt || defaultEncrypt)(msg, encryption.password) : noop;
}
function isValidPrivateKey(value) {
  return !!value.match(/^(0x)?[0-9a-f]{64}$/i);
}

// node_modules/@thirdweb-dev/wallets/evm/wallets/signer/dist/thirdweb-dev-wallets-evm-wallets-signer.browser.esm.js
init_shim();
init_lib3();
var _storage = /* @__PURE__ */ new WeakMap();
var SignerWallet = class extends AbstractClientWallet {
  constructor(options) {
    super("signerWallet", options);
    _classPrivateFieldInitSpec(this, _storage, {
      writable: true,
      value: void 0
    });
    if (options.clientId && options.chain) {
      options.chain = updateChainRPCs(options.chain, options.clientId);
    }
    this.options = options;
    this.signer = options.signer;
    _classPrivateFieldSet(this, _storage, (options == null ? void 0 : options.storage) || createAsyncLocalStorage(walletIds.localWallet));
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SignerConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-signer.browser.esm-ELMBY3VC.js");
      if (!this.signer) {
        this.signer = this.options.signer;
      }
      const defaults = (this.options.chain ? [...defaultChains, this.options.chain] : defaultChains).map((c2) => updateChainRPCs(c2, this.options.clientId));
      this.connector = new SignerConnector({
        chain: this.options.chain || updateChainRPCs(c1, this.options.clientId),
        signer: this.signer,
        chains: this.chains || defaults,
        clientId: this.options.clientId,
        secretKey: this.options.secretKey
      });
    }
    return this.connector;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/magic/dist/thirdweb-dev-wallets-evm-wallets-magic.browser.esm.js
init_shim();
init_lib3();
var MagicLink = class extends AbstractClientWallet {
  get walletName() {
    return "Magic Link";
  }
  constructor(options) {
    super(MagicLink.id, options);
    this.options = options;
  }
  async initializeConnector() {
    const {
      MagicAuthConnector
    } = await import("./thirdweb-dev-wallets-evm-connectors-magic.browser.esm-JIOHLBUY.js");
    const magicConnector = new MagicAuthConnector({
      chains: this.chains,
      options: this.options
    });
    this.magicConnector = magicConnector;
    this.connector = new WagmiAdapter(magicConnector);
    return this.connector;
  }
  async getConnector() {
    if (!this.connector) {
      return await this.initializeConnector();
    }
    return this.connector;
  }
  getMagic() {
    if (!this.magicConnector) {
      throw new Error("Magic connector is not initialized");
    }
    return this.magicConnector.getMagicSDK();
  }
  async autoConnect(options) {
    var _a;
    await this.initializeConnector();
    await ((_a = this.magicConnector) == null ? void 0 : _a.initializeMagicSDK(options));
    const magic = this.getMagic();
    {
      const url = new URL(window.location.href);
      const isMagicRedirect = url.searchParams.get("magic_credential");
      if (isMagicRedirect) {
        try {
          this.oAuthRedirectResult = await magic.oauth.getRedirectResult();
        } catch {
        }
      }
    }
    const isLoggedIn = await magic.user.isLoggedIn();
    if (isLoggedIn) {
      return super.autoConnect(options);
    }
    throw new Error("Magic user is not logged in");
  }
  async disconnect() {
    this.oAuthRedirectResult = void 0;
    const magic = this.getMagic();
    await magic.user.logout();
    return super.disconnect();
  }
  async connect(options) {
    if ("email" in options && this.options.emailLogin === false) {
      throw new Error("Email login is disabled");
    }
    if ("phoneNumber" in options && this.options.smsLogin === false) {
      throw new Error("SMS login is disabled");
    }
    return super.connect(options);
  }
};
_defineProperty(MagicLink, "meta", {
  iconURL: "ipfs://QmUMBFZGXxBpgDmZzZAHhbcCL5nYvZnVaYLTajsNjLcxMU/1-Icon_Magic_Color.svg",
  name: "Magic Link"
});
_defineProperty(MagicLink, "id", walletIds.magicLink);

// node_modules/@thirdweb-dev/wallets/evm/wallets/metamask/dist/thirdweb-dev-wallets-evm-wallets-metamask.browser.esm.js
init_shim();
init_lib3();
var MetaMaskWallet = class extends AbstractClientWallet {
  get walletName() {
    return "MetaMask";
  }
  constructor(options) {
    super(MetaMaskWallet.id, options);
    this.isInjected = !!getInjectedMetamaskProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          MetaMaskConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-metamask.browser.esm-THD5M6H3.js");
        const metamaskConnector = new MetaMaskConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.metamaskConnector = metamaskConnector;
        this.connector = new WagmiAdapter(metamaskConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-GFIRAGYJ.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
  async switchAccount() {
    if (!this.metamaskConnector) {
      throw new Error("Can not switch Account");
    }
    await this.metamaskConnector.switchAccount();
  }
};
_defineProperty(MetaMaskWallet, "meta", {
  name: "MetaMask",
  iconURL: "ipfs://QmZZHcw7zcXursywnLDAyY6Hfxzqop5GKgwoq8NB9jjrkN/metamask.svg",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
    android: "https://play.google.com/store/apps/details?id=io.metamask",
    ios: "https://apps.apple.com/us/app/metamask-blockchain-wallet/id1438144202"
  }
});
_defineProperty(MetaMaskWallet, "id", walletIds.metamask);

// node_modules/@thirdweb-dev/wallets/evm/wallets/phantom/dist/thirdweb-dev-wallets-evm-wallets-phantom.browser.esm.js
init_shim();
init_lib3();
var PhantomWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Phantom";
  }
  constructor(options) {
    super(PhantomWallet.id, options);
    this.isInjected = !!getInjectedPhantomProvider();
  }
  async getConnector() {
    if (!this.connector) {
      const {
        PhantomConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-phantom.browser.esm-GX2T2X6G.js");
      const phantomConnector = new PhantomConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      });
      this.phantomConnector = phantomConnector;
      this.connector = new WagmiAdapter(phantomConnector);
    }
    return this.connector;
  }
};
_defineProperty(PhantomWallet, "meta", {
  name: "Phantom",
  iconURL: "ipfs://bafybeibkpca5nwxpsjrtuxmz2ckb5lyc2sl2abg5f7dnvxku637vvffjti",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/phantom/bfnaelmomeimhlpmgjnjophhpkkoljpa"
  }
});
_defineProperty(PhantomWallet, "id", walletIds.phantom);

// node_modules/@thirdweb-dev/wallets/evm/wallets/rainbow-wallet/dist/thirdweb-dev-wallets-evm-wallets-rainbow-wallet.browser.esm.js
init_shim();
init_lib3();
var RainbowWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Rainbow Wallet";
  }
  constructor(options) {
    super(RainbowWallet.id, options);
    this.isInjected = !!getInjectedRainbowProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          RainbowConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-rainbow.browser.esm-GF6HTJBL.js");
        const rainbowConnector = new RainbowConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.rainbowConnector = rainbowConnector;
        this.connector = new WagmiAdapter(rainbowConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-GFIRAGYJ.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(RainbowWallet, "meta", {
  name: "Rainbow Wallet",
  iconURL: "ipfs://QmSZn47p4DVVBfzvg9BAX2EqwnPxkT1YAE7rUnrtd9CybQ/rainbow-logo.png",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/rainbow/opfgelmcmbiajamepnmloijbpoleiama",
    android: "https://rnbwapp.com/e/Va41HWS6Oxb",
    ios: "https://rnbwapp.com/e/OeMdmkJ6Oxb"
  }
});
_defineProperty(RainbowWallet, "id", walletIds.rainbow);

// node_modules/@thirdweb-dev/wallets/evm/wallets/safe/dist/thirdweb-dev-wallets-evm-wallets-safe.browser.esm.js
init_shim();
init_lib3();
var SafeWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Safe Wallet";
  }
  constructor(options) {
    super(SafeWallet.id, {
      ...options
    });
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SafeConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-safe.browser.esm-4ZBYHSEK.js");
      this.connector = new SafeConnector();
    }
    return this.connector;
  }
  async updateChains(chains) {
  }
  getPersonalWallet() {
    var _a;
    return (_a = this.connector) == null ? void 0 : _a.personalWallet;
  }
  autoConnect(params) {
    return this.connect(params);
  }
};
_defineProperty(SafeWallet, "meta", {
  name: "Safe",
  iconURL: "ipfs://QmbbyxDDmmLQh8DzzeUR6X6B75bESsNUFmbdvS3ZsQ2pN1/SafeToken.svg"
});
_defineProperty(SafeWallet, "id", walletIds.safe);

// node_modules/@thirdweb-dev/wallets/evm/wallets/trust/dist/thirdweb-dev-wallets-evm-wallets-trust.browser.esm.js
init_shim();
init_lib3();
var TrustWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Trust Wallet";
  }
  constructor(options) {
    var _a;
    super(TrustWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isTrust);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          TrustConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-trust.browser.esm-R7GBSF3F.js");
        const trustConnector = new TrustConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.trustConnector = trustConnector;
        this.connector = new WagmiAdapter(trustConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-GFIRAGYJ.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(TrustWallet, "meta", {
  name: "Trust Wallet",
  iconURL: "ipfs://QmNigQbXk7wKZwDcgN38Znj1ZZQ3JEG3DD6fUKLBU8SUTP/trust%20wallet.svg",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/trust-wallet/egjidjbpglichdcondbcbdnbeeppgdph",
    android: "https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp",
    ios: "https://apps.apple.com/us/app/trust-crypto-bitcoin-wallet/id1288339409"
  }
});
_defineProperty(TrustWallet, "id", walletIds.trust);

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect.browser.esm.js
init_shim();
init_lib3();
var _walletConnectConnector = /* @__PURE__ */ new WeakMap();
var _provider = /* @__PURE__ */ new WeakMap();
var _maybeThrowError = /* @__PURE__ */ new WeakMap();
var _onConnect = /* @__PURE__ */ new WeakMap();
var _onDisconnect = /* @__PURE__ */ new WeakMap();
var _onChange = /* @__PURE__ */ new WeakMap();
var _onMessage = /* @__PURE__ */ new WeakMap();
var _onSessionRequestSent = /* @__PURE__ */ new WeakMap();
var _setupListeners = /* @__PURE__ */ new WeakSet();
var _removeListeners = /* @__PURE__ */ new WeakSet();
var WalletConnect = class extends AbstractClientWallet {
  get walletName() {
    return "WalletConnect";
  }
  constructor(options) {
    super((options == null ? void 0 : options.walletId) || WalletConnect.id, options);
    _classPrivateMethodInitSpec(this, _removeListeners);
    _classPrivateMethodInitSpec(this, _setupListeners);
    _classPrivateFieldInitSpec(this, _walletConnectConnector, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _provider, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _maybeThrowError, {
      writable: true,
      value: (error) => {
        if (error) {
          throw error;
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onConnect, {
      writable: true,
      value: (data2) => {
        _classPrivateFieldSet(this, _provider, data2.provider);
        if (!_classPrivateFieldGet(this, _provider)) {
          throw new Error("WalletConnect provider not found after connecting.");
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onDisconnect, {
      writable: true,
      value: () => {
        _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);
      }
    });
    _classPrivateFieldInitSpec(this, _onChange, {
      writable: true,
      value: async (payload) => {
        if (payload.chain)
          ;
        else if (payload.account)
          ;
      }
    });
    _classPrivateFieldInitSpec(this, _onMessage, {
      writable: true,
      value: (payload) => {
        switch (payload.type) {
          case "display_uri":
            this.emit("display_uri", payload.data);
            break;
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onSessionRequestSent, {
      writable: true,
      value: () => {
        this.emit("wc_session_request_sent");
      }
    });
    this.projectId = (options == null ? void 0 : options.projectId) || TW_WC_PROJECT_ID;
    this.qrcode = (options == null ? void 0 : options.qrcode) === false ? false : true;
  }
  async getConnector() {
    var _a;
    if (!this.connector) {
      const {
        WalletConnectConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-GFIRAGYJ.js");
      _classPrivateFieldSet(this, _walletConnectConnector, new WalletConnectConnector({
        chains: this.chains,
        options: {
          qrcode: this.qrcode,
          projectId: this.projectId,
          dappMetadata: this.dappMetadata,
          storage: this.walletStorage,
          qrModalOptions: (_a = this.options) == null ? void 0 : _a.qrModalOptions
        }
      }));
      this.connector = new WagmiAdapter(_classPrivateFieldGet(this, _walletConnectConnector));
      _classPrivateFieldSet(this, _provider, await _classPrivateFieldGet(this, _walletConnectConnector).getProvider());
      _classPrivateMethodGet(this, _setupListeners, _setupListeners2).call(this);
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = _classPrivateFieldGet(this, _walletConnectConnector);
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
function _setupListeners2() {
  var _a;
  if (!_classPrivateFieldGet(this, _walletConnectConnector)) {
    return;
  }
  _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);
  _classPrivateFieldGet(this, _walletConnectConnector).on("connect", _classPrivateFieldGet(this, _onConnect));
  _classPrivateFieldGet(this, _walletConnectConnector).on("disconnect", _classPrivateFieldGet(this, _onDisconnect));
  _classPrivateFieldGet(this, _walletConnectConnector).on("change", _classPrivateFieldGet(this, _onChange));
  _classPrivateFieldGet(this, _walletConnectConnector).on("message", _classPrivateFieldGet(this, _onMessage));
  (_a = _classPrivateFieldGet(this, _provider)) == null ? void 0 : _a.signer.client.on("session_request_sent", _classPrivateFieldGet(this, _onSessionRequestSent));
}
function _removeListeners2() {
  var _a;
  if (!_classPrivateFieldGet(this, _walletConnectConnector)) {
    return;
  }
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("connect", _classPrivateFieldGet(this, _onConnect));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("disconnect", _classPrivateFieldGet(this, _onDisconnect));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("change", _classPrivateFieldGet(this, _onChange));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("message", _classPrivateFieldGet(this, _onMessage));
  (_a = _classPrivateFieldGet(this, _provider)) == null ? void 0 : _a.signer.client.removeListener("session_request_sent", _classPrivateFieldGet(this, _onSessionRequestSent));
}
_defineProperty(WalletConnect, "id", walletIds.walletConnect);
_defineProperty(WalletConnect, "meta", {
  name: "WalletConnect",
  iconURL: "ipfs://QmX58KPRaTC9JYZ7KriuBzeoEaV2P9eZcA3qbFnTHZazKw/wallet-connect.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/zerion/dist/thirdweb-dev-wallets-evm-wallets-zerion.browser.esm.js
init_shim();
init_lib3();
var ZerionWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Zerion Wallet";
  }
  constructor(options) {
    var _a;
    super(ZerionWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isZerion);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          ZerionConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-zerion.browser.esm-TNTNWSE2.js");
        const zerionConnector = new ZerionConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.zerionConnector = zerionConnector;
        this.connector = new WagmiAdapter(zerionConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-GFIRAGYJ.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(ZerionWallet, "id", "zerion");
_defineProperty(ZerionWallet, "meta", {
  name: "Zerion Wallet",
  iconURL: "ipfs://Qmb1LhNtMUkzbgk1V8ZiUSRXjMJGRkS5HH3R71KyRgjdBG/zerion.png",
  urls: {
    chrome: "https://zerion.io/extension",
    android: "https://link.zerion.io/901o6IN0jqb",
    ios: "https://link.zerion.io/a11o6IN0jqb"
  }
});

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/wallets/evm/wallets/ethers/dist/thirdweb-dev-wallets-evm-wallets-ethers.browser.esm.js
init_shim();
init_lib3();

// node_modules/@thirdweb-dev/wallets/evm/wallets/private-key/dist/thirdweb-dev-wallets-evm-wallets-private-key.browser.esm.js
init_shim();
init_lib3();

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect-v1/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect-v1.browser.esm.js
init_shim();
init_lib3();

// node_modules/@thirdweb-dev/wallets/evm/wallets/token-bound-smart-wallet/dist/thirdweb-dev-wallets-evm-wallets-token-bound-smart-wallet.browser.esm.js
init_shim();
init_lib3();
var TokenBoundSmartWallet = class extends SmartWallet {
  get walletName() {
    return "Token Bound Smart Wallet";
  }
  constructor(options) {
    super({
      ...options,
      factoryAddress: options.registryAddress || ERC6551_REGISTRY
    });
    this.tbaOptions = options;
  }
  async getConnector() {
    if (!this.tbaConnector) {
      if (this.enableConnectApp) {
        await this.wcWallet.init();
        this.setupWalletConnectEventsListeners();
      }
      const {
        TokenBoundSmartWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-token-bound-smart-wallet.browser.esm-P6FT6Q3M.js");
      this.tbaConnector = new TokenBoundSmartWalletConnector(this.tbaOptions);
    }
    return this.tbaConnector;
  }
};
_defineProperty(TokenBoundSmartWallet, "meta", {
  name: "Token Bound Smart Wallet",
  iconURL: "ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg"
});
_defineProperty(TokenBoundSmartWallet, "id", walletIds.tokenBoundSmartWallet);

// node_modules/@thirdweb-dev/wallets/dist/auth-e91a1229.browser.esm.js
init_shim();
var RecoveryShareManagement = function(RecoveryShareManagement2) {
  RecoveryShareManagement2["USER_MANAGED"] = "USER_MANAGED";
  RecoveryShareManagement2["AWS_MANAGED"] = "AWS_MANAGED";
  return RecoveryShareManagement2;
}({});
var AuthProvider = function(AuthProvider2) {
  AuthProvider2["COGNITO"] = "Cognito";
  return AuthProvider2;
}({});

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
init_lib3();
var import_buffer2 = __toESM(require_buffer());
var import_utils7 = __toESM(require_utils());

export {
  createAsyncLocalStorage,
  setWalletAnalyticsEnabled,
  SmartWallet,
  OKXWallet,
  getInjectedCoinbaseProvider,
  PaperWallet,
  BloctoWallet,
  CoinbaseWallet,
  EmbeddedWallet2 as EmbeddedWallet,
  FrameWallet,
  InjectedWallet,
  LocalWallet,
  SignerWallet,
  MagicLink,
  MetaMaskWallet,
  PhantomWallet,
  RainbowWallet,
  SafeWallet,
  TrustWallet,
  WalletConnect,
  ZerionWallet
};
//# sourceMappingURL=chunk-NMNJ7A2O.js.map
