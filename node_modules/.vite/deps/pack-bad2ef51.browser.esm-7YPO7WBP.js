import {
  PackMetadataInputSchema,
  PackRewardsOutputSchema
} from "./chunk-VYVRMGTH.js";
import {
  hasERC20Allowance
} from "./chunk-5EVIAGR2.js";
import {
  StandardErc1155
} from "./chunk-VIG57T5U.js";
import {
  AbiSchema,
  ContractAppURI,
  ContractEncoder,
  ContractEvents,
  ContractInterceptor,
  ContractMetadata,
  ContractOwner,
  ContractRoles,
  ContractRoyalty,
  ContractWrapper,
  Erc20,
  FEATURE_PACK_VRF,
  GasCostEstimator,
  IERC20_default,
  IPackVRFDirect_default,
  LINK_TOKEN_ADDRESS,
  PACK_CONTRACT_ROLES,
  PackContractSchema,
  Transaction,
  assertEnabled,
  buildTransactionFunction,
  detectContractFeature,
  fetchCurrencyMetadata,
  getRoleHash,
  isTokenApprovedForTransfer,
  normalizePriceValue,
  require_bs58,
  require_dist,
  require_fast_deep_equal,
  resolveAddress,
  uploadOrExtractURI
} from "./chunk-EZZX3VV7.js";
import "./chunk-QZ5GEFHZ.js";
import "./chunk-I4TCAHS5.js";
import "./chunk-457LSDR5.js";
import {
  init_lib,
  utils_exports
} from "./chunk-DTB7S26G.js";
import "./chunk-O2O3ULHT.js";
import {
  require_utils
} from "./chunk-MD4EOBS2.js";
import "./chunk-3327Y7YD.js";
import {
  BigNumber,
  lib_exports8 as lib_exports
} from "./chunk-KAA6TFSL.js";
import "./chunk-NO757KM3.js";
import {
  require_bn
} from "./chunk-37L3W2XO.js";
import {
  init_shim
} from "./chunk-6SWLQQ3Q.js";
import {
  __publicField,
  __toESM
} from "./chunk-GN3OLCG2.js";

// node_modules/@thirdweb-dev/sdk/dist/pack-bad2ef51.browser.esm.js
init_shim();
init_lib();
var import_bn = __toESM(require_bn());
var import_utils = __toESM(require_utils());
var import_bs58 = __toESM(require_bs58());
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var import_merkletreejs = __toESM(require_dist());
var PackVRF = class {
  constructor(network, address, storage, options, chainId) {
    __publicField(this, "featureName", FEATURE_PACK_VRF.name);
    __publicField(this, "open", buildTransactionFunction((() => {
      var _this = this;
      return async function(tokenId) {
        let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        let gasLimit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5e5;
        return Transaction.fromContractWrapper({
          contractWrapper: _this.contractWrapper,
          method: "openPack",
          args: [tokenId, amount],
          overrides: {
            gasLimit
          },
          parse: (receipt) => {
            let id = BigNumber.from(0);
            try {
              const event = _this.contractWrapper.parseLogs("PackOpenRequested", receipt == null ? void 0 : receipt.logs);
              id = event[0].args.requestId;
            } catch (e) {
            }
            return {
              receipt,
              id
            };
          }
        });
      };
    })()));
    __publicField(this, "claimRewards", buildTransactionFunction((() => {
      var _this2 = this;
      return async function() {
        let gasLimit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5e5;
        return Transaction.fromContractWrapper({
          contractWrapper: _this2.contractWrapper,
          method: "claimRewards",
          args: [],
          overrides: {
            gasLimit
          },
          parse: async (receipt) => {
            const event = _this2.contractWrapper.parseLogs("PackOpened", receipt == null ? void 0 : receipt.logs);
            if (event.length === 0) {
              throw new Error("PackOpened event not found");
            }
            const rewards = event[0].args.rewardUnitsDistributed;
            return await _this2.parseRewards(rewards);
          }
        });
      };
    })()));
    let contractWrapper = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : new ContractWrapper(network, address, IPackVRFDirect_default, options, storage);
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.chainId = chainId;
    this.events = new ContractEvents(this.contractWrapper);
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  async parseRewards(rewards) {
    const erc20Rewards = [];
    const erc721Rewards = [];
    const erc1155Rewards = [];
    for (const reward of rewards) {
      switch (reward.tokenType) {
        case 0: {
          const tokenMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), reward.assetContract);
          erc20Rewards.push({
            contractAddress: reward.assetContract,
            quantityPerReward: utils_exports.formatUnits(reward.totalAmount, tokenMetadata.decimals).toString()
          });
          break;
        }
        case 1: {
          erc721Rewards.push({
            contractAddress: reward.assetContract,
            tokenId: reward.tokenId.toString()
          });
          break;
        }
        case 2: {
          erc1155Rewards.push({
            contractAddress: reward.assetContract,
            tokenId: reward.tokenId.toString(),
            quantityPerReward: reward.totalAmount.toString()
          });
          break;
        }
      }
    }
    return {
      erc20Rewards,
      erc721Rewards,
      erc1155Rewards
    };
  }
  async addPackOpenEventListener(callback) {
    return this.events.addEventListener("PackOpened", async (event) => {
      callback(event.data.packId.toString(), event.data.opener, await this.parseRewards(event.data.rewardUnitsDistributed));
    });
  }
  async canClaimRewards(claimerAddress) {
    const address = await resolveAddress(claimerAddress || await this.contractWrapper.getSignerAddress());
    return await this.contractWrapper.read("canClaimRewards", [address]);
  }
  async openAndClaim(packId) {
    let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    let gasLimit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5e5;
    const receipt = await this.contractWrapper.sendTransaction("openPackAndClaimRewards", [packId, amount, gasLimit], {
      gasLimit: BigNumber.from(5e5)
    });
    let id = BigNumber.from(0);
    try {
      const event = this.contractWrapper.parseLogs("PackOpenRequested", receipt == null ? void 0 : receipt.logs);
      id = event[0].args.requestId;
    } catch (e) {
    }
    return {
      receipt,
      id
    };
  }
  async getLinkBalance() {
    return this.getLinkContract().balanceOf(this.contractWrapper.address);
  }
  async transferLink(amount) {
    await this.getLinkContract().transfer(this.contractWrapper.address, amount);
  }
  getLinkContract() {
    const linkAddress = LINK_TOKEN_ADDRESS[this.chainId];
    if (!linkAddress) {
      throw new Error(`No LINK token address found for chainId ${this.chainId}`);
    }
    const contract = new ContractWrapper(this.contractWrapper.getSignerOrProvider(), linkAddress, IERC20_default, this.contractWrapper.options, this.storage);
    return new Erc20(contract, this.storage, this.chainId);
  }
};
var _Pack = class extends StandardErc1155 {
  constructor(network, address, storage) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    let abi = arguments.length > 4 ? arguments[4] : void 0;
    let chainId = arguments.length > 5 ? arguments[5] : void 0;
    let contractWrapper = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : new ContractWrapper(network, address, abi, options.gasless && "openzeppelin" in options.gasless ? {
      ...options,
      gasless: {
        ...options.gasless,
        openzeppelin: {
          ...options.gasless.openzeppelin,
          useEOAForwarder: true
        }
      }
    } : options, storage);
    super(contractWrapper, storage, chainId);
    __publicField(this, "create", buildTransactionFunction(async (metadataWithRewards) => {
      const signerAddress = await this.contractWrapper.getSignerAddress();
      return this.createTo.prepare(signerAddress, metadataWithRewards);
    }));
    __publicField(this, "addPackContents", buildTransactionFunction(async (packId, packContents) => {
      const [signerAddress, parsedContents] = await Promise.all([this.contractWrapper.getSignerAddress(), PackRewardsOutputSchema.parseAsync(packContents)]);
      const {
        contents,
        numOfRewardUnits
      } = await this.toPackContentArgs(parsedContents);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "addPackContents",
        args: [packId, contents, numOfRewardUnits, signerAddress],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("PackUpdated", receipt == null ? void 0 : receipt.logs);
          if (event.length === 0) {
            throw new Error("PackUpdated event not found");
          }
          const id = event[0].args.packId;
          return {
            id,
            receipt,
            data: () => this.erc1155.get(id)
          };
        }
      });
    }));
    __publicField(this, "createTo", buildTransactionFunction(async (to, metadataWithRewards) => {
      const [uri, parsedMetadata, toAddress] = await Promise.all([uploadOrExtractURI(metadataWithRewards.packMetadata, this.storage), PackMetadataInputSchema.parseAsync(metadataWithRewards), resolveAddress(to)]);
      const {
        erc20Rewards,
        erc721Rewards,
        erc1155Rewards
      } = parsedMetadata;
      const rewardsData = {
        erc20Rewards,
        erc721Rewards,
        erc1155Rewards
      };
      const {
        contents,
        numOfRewardUnits
      } = await this.toPackContentArgs(rewardsData);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "createPack",
        args: [contents, numOfRewardUnits, uri, parsedMetadata.openStartTime, parsedMetadata.rewardsPerPack, toAddress],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("PackCreated", receipt == null ? void 0 : receipt.logs);
          if (event.length === 0) {
            throw new Error("PackCreated event not found");
          }
          const packId = event[0].args.packId;
          return {
            id: packId,
            receipt,
            data: () => this.erc1155.get(packId)
          };
        }
      });
    }));
    __publicField(this, "open", buildTransactionFunction((() => {
      var _this = this;
      return async function(tokenId) {
        let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        let gasLimit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5e5;
        if (_this._vrf) {
          throw new Error("This contract is using Chainlink VRF, use `contract.vrf.open()` or `contract.vrf.openAndClaim()` instead");
        }
        return Transaction.fromContractWrapper({
          contractWrapper: _this.contractWrapper,
          method: "openPack",
          args: [tokenId, amount],
          overrides: {
            gasLimit
          },
          parse: async (receipt) => {
            const event = _this.contractWrapper.parseLogs("PackOpened", receipt == null ? void 0 : receipt.logs);
            if (event.length === 0) {
              throw new Error("PackOpened event not found");
            }
            const rewards = event[0].args.rewardUnitsDistributed;
            const erc20Rewards = [];
            const erc721Rewards = [];
            const erc1155Rewards = [];
            for (const reward of rewards) {
              switch (reward.tokenType) {
                case 0: {
                  const tokenMetadata = await fetchCurrencyMetadata(_this.contractWrapper.getProvider(), reward.assetContract);
                  erc20Rewards.push({
                    contractAddress: reward.assetContract,
                    quantityPerReward: utils_exports.formatUnits(reward.totalAmount, tokenMetadata.decimals).toString()
                  });
                  break;
                }
                case 1: {
                  erc721Rewards.push({
                    contractAddress: reward.assetContract,
                    tokenId: reward.tokenId.toString()
                  });
                  break;
                }
                case 2: {
                  erc1155Rewards.push({
                    contractAddress: reward.assetContract,
                    tokenId: reward.tokenId.toString(),
                    quantityPerReward: reward.totalAmount.toString()
                  });
                  break;
                }
              }
            }
            return {
              erc20Rewards,
              erc721Rewards,
              erc1155Rewards
            };
          }
        });
      };
    })()));
    this.abi = AbiSchema.parse(abi || []);
    this.metadata = new ContractMetadata(this.contractWrapper, PackContractSchema, this.storage);
    this.app = new ContractAppURI(this.contractWrapper, this.metadata, this.storage);
    this.roles = new ContractRoles(this.contractWrapper, _Pack.contractRoles);
    this.royalties = new ContractRoyalty(this.contractWrapper, this.metadata);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
    this.events = new ContractEvents(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
    this.owner = new ContractOwner(this.contractWrapper);
    this._vrf = this.detectVrf();
  }
  get vrf() {
    return assertEnabled(this._vrf, FEATURE_PACK_VRF);
  }
  onNetworkUpdated(network) {
    var _a;
    this.contractWrapper.updateSignerOrProvider(network);
    (_a = this._vrf) == null ? void 0 : _a.onNetworkUpdated(network);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  async get(tokenId) {
    return this.erc1155.get(tokenId);
  }
  async getAll(queryParams) {
    return this.erc1155.getAll(queryParams);
  }
  async getOwned(walletAddress) {
    return this.erc1155.getOwned(walletAddress);
  }
  async getTotalCount() {
    return this.erc1155.totalCount();
  }
  async isTransferRestricted() {
    const anyoneCanTransfer = await this.contractWrapper.read("hasRole", [getRoleHash("transfer"), lib_exports.AddressZero]);
    return !anyoneCanTransfer;
  }
  async getPackContents(packId) {
    const {
      contents,
      perUnitAmounts
    } = await this.contractWrapper.read("getPackContents", [packId]);
    const erc20Rewards = [];
    const erc721Rewards = [];
    const erc1155Rewards = [];
    for (let i = 0; i < contents.length; i++) {
      const reward = contents[i];
      const amount = perUnitAmounts[i];
      switch (reward.tokenType) {
        case 0: {
          const tokenMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), reward.assetContract);
          const quantityPerReward = utils_exports.formatUnits(amount, tokenMetadata.decimals);
          const totalRewards = utils_exports.formatUnits(BigNumber.from(reward.totalAmount).div(amount), tokenMetadata.decimals);
          erc20Rewards.push({
            contractAddress: reward.assetContract,
            quantityPerReward,
            totalRewards
          });
          break;
        }
        case 1: {
          erc721Rewards.push({
            contractAddress: reward.assetContract,
            tokenId: reward.tokenId.toString()
          });
          break;
        }
        case 2: {
          erc1155Rewards.push({
            contractAddress: reward.assetContract,
            tokenId: reward.tokenId.toString(),
            quantityPerReward: amount.toString(),
            totalRewards: BigNumber.from(reward.totalAmount).div(amount).toString()
          });
          break;
        }
      }
    }
    return {
      erc20Rewards,
      erc721Rewards,
      erc1155Rewards
    };
  }
  async toPackContentArgs(metadataWithRewards) {
    const contents = [];
    const numOfRewardUnits = [];
    const {
      erc20Rewards,
      erc721Rewards,
      erc1155Rewards
    } = metadataWithRewards;
    const provider = this.contractWrapper.getProvider();
    const owner = await this.contractWrapper.getSignerAddress();
    for (const erc20 of erc20Rewards) {
      const normalizedQuantity = await normalizePriceValue(provider, erc20.quantityPerReward, erc20.contractAddress);
      const totalQuantity = normalizedQuantity.mul(erc20.totalRewards);
      const hasAllowance = await hasERC20Allowance(this.contractWrapper, erc20.contractAddress, totalQuantity);
      if (!hasAllowance) {
        throw new Error(`ERC20 token with contract address "${erc20.contractAddress}" does not have enough allowance to transfer.

You can set allowance to the multiwrap contract to transfer these tokens by running:

await sdk.getToken("${erc20.contractAddress}").setAllowance("${this.getAddress()}", ${totalQuantity});

`);
      }
      numOfRewardUnits.push(erc20.totalRewards);
      contents.push({
        assetContract: erc20.contractAddress,
        tokenType: 0,
        totalAmount: totalQuantity,
        tokenId: 0
      });
    }
    for (const erc721 of erc721Rewards) {
      const isApproved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), erc721.contractAddress, erc721.tokenId, owner);
      if (!isApproved) {
        throw new Error(`ERC721 token "${erc721.tokenId}" with contract address "${erc721.contractAddress}" is not approved for transfer.

You can give approval the multiwrap contract to transfer this token by running:

await sdk.getNFTCollection("${erc721.contractAddress}").setApprovalForToken("${this.getAddress()}", ${erc721.tokenId});

`);
      }
      numOfRewardUnits.push("1");
      contents.push({
        assetContract: erc721.contractAddress,
        tokenType: 1,
        totalAmount: 1,
        tokenId: erc721.tokenId
      });
    }
    for (const erc1155 of erc1155Rewards) {
      const isApproved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), erc1155.contractAddress, erc1155.tokenId, owner);
      if (!isApproved) {
        throw new Error(`ERC1155 token "${erc1155.tokenId}" with contract address "${erc1155.contractAddress}" is not approved for transfer.

You can give approval the multiwrap contract to transfer this token by running:

await sdk.getEdition("${erc1155.contractAddress}").setApprovalForAll("${this.getAddress()}", true);

`);
      }
      numOfRewardUnits.push(erc1155.totalRewards);
      contents.push({
        assetContract: erc1155.contractAddress,
        tokenType: 2,
        totalAmount: BigNumber.from(erc1155.quantityPerReward).mul(BigNumber.from(erc1155.totalRewards)),
        tokenId: erc1155.tokenId
      });
    }
    return {
      contents,
      numOfRewardUnits
    };
  }
  async prepare(method, args, overrides) {
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method,
      args,
      overrides
    });
  }
  async call(functionName, args, overrides) {
    return this.contractWrapper.call(functionName, args, overrides);
  }
  detectVrf() {
    if (detectContractFeature(this.contractWrapper, "PackVRF")) {
      return new PackVRF(this.contractWrapper.getSignerOrProvider(), this.contractWrapper.address, this.storage, this.contractWrapper.options, this.chainId);
    }
    return void 0;
  }
};
var Pack = _Pack;
__publicField(Pack, "contractRoles", PACK_CONTRACT_ROLES);
export {
  Pack
};
//# sourceMappingURL=pack-bad2ef51.browser.esm-7YPO7WBP.js.map
