import {
  ListingType,
  MarketplaceAuction,
  MarketplaceDirect
} from "./chunk-IWAQ54DQ.js";
import {
  AbiSchema,
  ContractAppURI,
  ContractEncoder,
  ContractEvents,
  ContractInterceptor,
  ContractMetadata,
  ContractPlatformFee,
  ContractRoles,
  ContractWrapper,
  DEFAULT_QUERY_ALL_COUNT,
  GasCostEstimator,
  ListingNotFoundError,
  MARKETPLACE_CONTRACT_ROLES,
  MarketplaceContractSchema,
  NATIVE_TOKENS,
  Transaction,
  buildTransactionFunction,
  getRoleHash,
  invariant,
  isNativeToken,
  mapOffer,
  require_bs58,
  require_dist,
  require_fast_deep_equal
} from "./chunk-EZZX3VV7.js";
import "./chunk-QZ5GEFHZ.js";
import "./chunk-I4TCAHS5.js";
import "./chunk-457LSDR5.js";
import {
  init_lib
} from "./chunk-DTB7S26G.js";
import "./chunk-O2O3ULHT.js";
import {
  require_utils
} from "./chunk-MD4EOBS2.js";
import "./chunk-3327Y7YD.js";
import {
  BigNumber,
  lib_exports8 as lib_exports
} from "./chunk-KAA6TFSL.js";
import "./chunk-NO757KM3.js";
import {
  require_bn
} from "./chunk-37L3W2XO.js";
import {
  init_shim
} from "./chunk-6SWLQQ3Q.js";
import {
  __publicField,
  __toESM
} from "./chunk-GN3OLCG2.js";

// node_modules/@thirdweb-dev/sdk/dist/marketplace-52e6c187.browser.esm.js
init_shim();
init_lib();
var import_bn = __toESM(require_bn());
var import_utils = __toESM(require_utils());
var import_bs58 = __toESM(require_bs58());
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var import_merkletreejs = __toESM(require_dist());
var _Marketplace = class {
  constructor(network, address, storage) {
    __publicField(this, "getAll", this.getAllListings);
    __publicField(this, "buyoutListing", buildTransactionFunction(async (listingId, quantityDesired, receiver) => {
      const listing = await this.contractWrapper.read("listings", [listingId]);
      if (listing.listingId.toString() !== listingId.toString()) {
        throw new ListingNotFoundError(this.getAddress(), listingId.toString());
      }
      switch (listing.listingType) {
        case ListingType.Direct: {
          invariant(quantityDesired !== void 0, "quantityDesired is required when buying out a direct listing");
          return await this.direct.buyoutListing.prepare(listingId, quantityDesired, receiver);
        }
        case ListingType.Auction: {
          return await this.auction.buyoutListing.prepare(listingId);
        }
        default:
          throw Error(`Unknown listing type: ${listing.listingType}`);
      }
    }));
    __publicField(this, "makeOffer", buildTransactionFunction(async (listingId, pricePerToken, quantity) => {
      const listing = await this.contractWrapper.read("listings", [listingId]);
      if (listing.listingId.toString() !== listingId.toString()) {
        throw new ListingNotFoundError(this.getAddress(), listingId.toString());
      }
      const chainId = await this.contractWrapper.getChainID();
      switch (listing.listingType) {
        case ListingType.Direct: {
          invariant(quantity, "quantity is required when making an offer on a direct listing");
          return await this.direct.makeOffer.prepare(listingId, quantity, isNativeToken(listing.currency) ? NATIVE_TOKENS[chainId].wrapped.address : listing.currency, pricePerToken);
        }
        case ListingType.Auction: {
          return await this.auction.makeBid.prepare(listingId, pricePerToken);
        }
        default:
          throw Error(`Unknown listing type: ${listing.listingType}`);
      }
    }));
    __publicField(this, "setBidBufferBps", buildTransactionFunction(async (bufferBps) => {
      await this.roles.verify(["admin"], await this.contractWrapper.getSignerAddress());
      const timeBuffer = await this.getTimeBufferInSeconds();
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setAuctionBuffers",
        args: [timeBuffer, BigNumber.from(bufferBps)]
      });
    }));
    __publicField(this, "setTimeBufferInSeconds", buildTransactionFunction(async (bufferInSeconds) => {
      await this.roles.verify(["admin"], await this.contractWrapper.getSignerAddress());
      const bidBuffer = await this.getBidBufferBps();
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setAuctionBuffers",
        args: [BigNumber.from(bufferInSeconds), bidBuffer]
      });
    }));
    __publicField(this, "allowListingFromSpecificAssetOnly", buildTransactionFunction(async (contractAddress) => {
      const encoded = [];
      const members = await this.roles.get("asset");
      if (members.includes(lib_exports.AddressZero)) {
        encoded.push(this.encoder.encode("revokeRole", [getRoleHash("asset"), lib_exports.AddressZero]));
      }
      encoded.push(this.encoder.encode("grantRole", [getRoleHash("asset"), contractAddress]));
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [encoded]
      });
    }));
    __publicField(this, "allowListingFromAnyAsset", buildTransactionFunction(async () => {
      const encoded = [];
      const members = await this.roles.get("asset");
      for (const addr in members) {
        encoded.push(this.encoder.encode("revokeRole", [getRoleHash("asset"), addr]));
      }
      encoded.push(this.encoder.encode("grantRole", [getRoleHash("asset"), lib_exports.AddressZero]));
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [encoded]
      });
    }));
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    let abi = arguments.length > 4 ? arguments[4] : void 0;
    let chainId = arguments.length > 5 ? arguments[5] : void 0;
    let contractWrapper = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : new ContractWrapper(network, address, abi, options, storage);
    this._chainId = chainId;
    this.abi = AbiSchema.parse(abi || []);
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.metadata = new ContractMetadata(this.contractWrapper, MarketplaceContractSchema, this.storage);
    this.app = new ContractAppURI(this.contractWrapper, this.metadata, this.storage);
    this.roles = new ContractRoles(this.contractWrapper, _Marketplace.contractRoles);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
    this.direct = new MarketplaceDirect(this.contractWrapper, this.storage);
    this.auction = new MarketplaceAuction(this.contractWrapper, this.storage);
    this.events = new ContractEvents(this.contractWrapper);
    this.platformFees = new ContractPlatformFee(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
  }
  get chainId() {
    return this._chainId;
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  async getListing(listingId) {
    const listing = await this.contractWrapper.read("listings", [listingId]);
    if (listing.assetContract === lib_exports.AddressZero) {
      throw new ListingNotFoundError(this.getAddress(), listingId.toString());
    }
    switch (listing.listingType) {
      case ListingType.Auction: {
        return await this.auction.mapListing(listing);
      }
      case ListingType.Direct: {
        return await this.direct.mapListing(listing);
      }
      default: {
        throw new Error(`Unknown listing type: ${listing.listingType}`);
      }
    }
  }
  async getActiveListings(filter) {
    const rawListings = await this.getAllListingsNoFilter(true);
    const filtered = this.applyFilter(rawListings, filter);
    const now = BigNumber.from(Math.floor(Date.now() / 1e3));
    return filtered.filter((l) => {
      return l.type === ListingType.Auction && BigNumber.from(l.endTimeInEpochSeconds).gt(now) && BigNumber.from(l.startTimeInEpochSeconds).lte(now) || l.type === ListingType.Direct && BigNumber.from(l.quantity).gt(0);
    });
  }
  async getAllListings(filter) {
    const rawListings = await this.getAllListingsNoFilter(false);
    return this.applyFilter(rawListings, filter);
  }
  async getTotalCount() {
    return await this.contractWrapper.read("totalListings", []);
  }
  async isRestrictedToListerRoleOnly() {
    const anyoneCanList = await this.contractWrapper.read("hasRole", [getRoleHash("lister"), lib_exports.AddressZero]);
    return !anyoneCanList;
  }
  async getBidBufferBps() {
    return this.contractWrapper.read("bidBufferBps", []);
  }
  async getTimeBufferInSeconds() {
    return this.contractWrapper.read("timeBuffer", []);
  }
  async getOffers(listingId) {
    const listingEvents = await this.events.getEvents("NewOffer", {
      order: "desc",
      filters: {
        listingId
      }
    });
    return await Promise.all(listingEvents.map((e) => {
      return mapOffer(this.contractWrapper.getProvider(), BigNumber.from(listingId), {
        quantityWanted: e.data.quantityWanted,
        pricePerToken: e.data.quantityWanted.gt(0) ? e.data.totalOfferAmount.div(e.data.quantityWanted) : e.data.totalOfferAmount,
        currency: e.data.currency,
        offeror: e.data.offeror
      });
    }));
  }
  async getAllListingsNoFilter(filterInvalidListings) {
    const listings = await Promise.all(Array.from(Array((await this.contractWrapper.read("totalListings", [])).toNumber()).keys()).map(async (i) => {
      let listing;
      try {
        listing = await this.getListing(i);
      } catch (err) {
        if (err instanceof ListingNotFoundError) {
          return void 0;
        } else {
          console.warn(`Failed to get listing ${i}' - skipping. Try 'marketplace.getListing(${i})' to get the underlying error.`);
          return void 0;
        }
      }
      if (listing.type === ListingType.Auction) {
        return listing;
      }
      if (filterInvalidListings) {
        const {
          valid
        } = await this.direct.isStillValidListing(listing);
        if (!valid) {
          return void 0;
        }
      }
      return listing;
    }));
    return listings.filter((l) => l !== void 0);
  }
  applyFilter(listings, filter) {
    let rawListings = [...listings];
    const start = BigNumber.from((filter == null ? void 0 : filter.start) || 0).toNumber();
    const count = BigNumber.from((filter == null ? void 0 : filter.count) || DEFAULT_QUERY_ALL_COUNT).toNumber();
    if (filter) {
      if (filter.seller) {
        rawListings = rawListings.filter((seller) => {
          var _a;
          return seller.sellerAddress.toString().toLowerCase() === ((_a = filter == null ? void 0 : filter.seller) == null ? void 0 : _a.toString().toLowerCase());
        });
      }
      if (filter.tokenContract) {
        rawListings = rawListings.filter((tokenContract) => {
          var _a;
          return tokenContract.assetContractAddress.toString().toLowerCase() === ((_a = filter == null ? void 0 : filter.tokenContract) == null ? void 0 : _a.toString().toLowerCase());
        });
      }
      if (filter.tokenId !== void 0) {
        rawListings = rawListings.filter((tokenContract) => {
          var _a;
          return tokenContract.tokenId.toString() === ((_a = filter == null ? void 0 : filter.tokenId) == null ? void 0 : _a.toString());
        });
      }
      rawListings = rawListings.filter((_, index) => index >= start);
      rawListings = rawListings.slice(0, count);
    }
    return rawListings;
  }
  async prepare(method, args, overrides) {
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method,
      args,
      overrides
    });
  }
  async call(functionName, args, overrides) {
    return this.contractWrapper.call(functionName, args, overrides);
  }
};
var Marketplace = _Marketplace;
__publicField(Marketplace, "contractRoles", MARKETPLACE_CONTRACT_ROLES);
export {
  Marketplace
};
//# sourceMappingURL=marketplace-52e6c187.browser.esm-2AOB62HL.js.map
